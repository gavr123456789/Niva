type Program
  io: IO_Container


type FilePath = String
type FileContent = String

type NivaSourceFile
  path: String
  nameWithoutExt: String

type IO_Container
  readFile: [FilePath -> String]
  writeFile: [FilePath, FileContent -> Unit]
  walkDir: [FilePath -> List::NivaSourceFile]
  getParent: [String -> String]
  currentDir: String
  runProgram: [List::String -> ]

constructor IO_Container new -> IO_Container = [
  readFile::[FilePath -> String] = [path::String ->
    FileSystem read: (path toPath)
  ]


  writeFile = [path::String , fileContent::FileContent->
    FileSystem write: path toPath
               content: fileContent
    Unit
  ]

  walkDir::[FilePath -> List::NivaSourceFile] = [path::String ->
    x = FileSystem listRecursively: path toPath

    x map: [
      NivaSourceFile path: it toString nameWithoutExt: (it name substringBeforeLast: ".")
    ]
  ]

  getParent = [path::String -> path toPath parent unpackOrPANIC toString]

  runProgram = [args::List::String ->
    processBuilder = ProcessBuilder command: args
    processBuilder redirectOutput start waitFor
    Unit
  ]

  ^ IO_Container :readFile :writeFile :walkDir :getParent currentDir: "." :runProgram
]




compilerTry = [
  path = "/Users/gavriil.maksyutenko/Documents/Fun/niva_demo/main.niva"
  NivaCompiler runArgs: {"build" path} withIO: IO_Container new
] do



testGenerics = [
  fileMain = """
    type Box x: T
    box = Box x: 42
    Box foo::T bar::G -> T = [
        ^ foo
    ]
    res = box foo: 1 bar: 6
  """


  result = ResolverHelper resolve: #{"main" fileMain} entryPoint: "main"
  db = result db
  typedAst = result entryPointExpressions last
  typedAst

]


collectionsTestingMapTry = [
  fileMain = """
    {1 2 3}
    #("1" "2" "3")
    #{1 "a" 2 "b"}
  //{"a" 1 "b" 2}
  """
  result = ResolverHelper
    resolve: #{"main" fileMain}
    entryPoint: "main"

  db = result db
  typedAst = result entryPointExpressions

  checkFirstList = [
    t = typedAst at: 0, typeInfo t
    | t
    | ListT => Assert that: t t name equals: "Int"
    |=> [TO DO: "list expected"]
  ] do

  checkSecondSet = [
    t = typedAst at: 1, typeInfo t
    | t
    | SetT => Assert that: t t name equals: "String"
    |=> [TO DO: "set expected"]
  ] do

  checkThirdMap = [
    t = typedAst at: 2, typeInfo t
    | t
    | MapT => [
      keyType = t k
      valueType = t v
      Assert that: keyType name equals: "Int"
      Assert that: valueType name equals: "String"
    ]
    |=> [TO DO: "map expected but got: $t"]
  ] do

]
