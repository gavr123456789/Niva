type Program
  io: IO


type FilePath = String
type FileContent = String

type NivaSourceFile
  path: String 
  nameWithoutExt: String

type IO
  readFile: [FilePath -> String]
  writeFile: [FilePath, FileContent -> Unit] // 
  walkDir: [FilePath -> List::NivaSourceFile]
  getParent: [String -> String]
  currentDir: String 

constructor IO new -> IO= [
  readFile::[FilePath -> String] = [path::String ->
    FileSystem read: (path toPath)
  ]

  writeFile = [path::String , fileContent::FileContent->
    FileSystem write: fileContent toPath 
               content: fileContent
    Unit
  ]

  walkDir::[FilePath -> List::NivaSourceFile] = [path::String ->
    x = FileSystem listRecursively: path toPath

    x map: [
      NivaSourceFile path: it toString nameWithoutExt: (it name substringBeforeLast: ".") 
    ]
  ]
  
  getParent = [path::String -> path toPath parent unpackOrPANIC name]

  ^ IO :readFile :writeFile :walkDir :getParent currentDir: "."
]


compilerTry = [
  path = "/home/gavr/Documents/Fun/Kotlin/Niva/Niva/NivaInNiva/compilerTest/entryPoint.niva"
  NivaCompiler runArgs: {"build" path} withIO: IO new

] do

codeblockCall = [
  fileMain = """
    x = [
      1
    ]
    
    x do
  """
  
  result = ResolverHelper resolve: #{"main" fileMain} entryPoint: "main"
  
  db = result db
  typedAst = result entryPointExpressions 


  checkFirst = [
    codeBlock = typedAst at: 0
    | codeBlock 
    | CodeBlockT => [
      Assert that: codeBlock args count equals: 0
      t = codeBlock typeInfo t
      | t 
      | FuntionT => [
        Assert that: t returnType name equals: "Int"
      ] 
      |=> [TO DO: "function type expected"]

    ] 
    |=> [TO DO: "codeblock expected"]
  ] 


] 



pkgImports = [
  fileMain = """
    type FirstType

    FirstType method1 = [
      SecondType new
    ]
    FirstType toString -> String = [
      ThirdType new
      ^ ""
    ]
    FirstType + x::Int = []
  """

  second = "type SecondType"
  third = "type ThirdType"



  result = ResolverHelper resolve: #{"main"   fileMain 
                                     "second" second 
                                     "third"  third} 
                          entryPoint: "main"
  // result entryPointExpressions at: 0, debug
  result db structureInfo echo

] 

stupidBackExperiment = [
  fileMain = """
    x = "sas"
    x at: 0
    add = [x::Int, y::Int -> x + y]
    add x: 1 y: 2
  """
  
  result = ResolverHelper resolve: #{"main" fileMain} entryPoint: "main"
  x = TypeScript rh: result
  x log
]



resolveMatch = [
  fileMain = """
    | 1
    | 1 => [1 echo]
    | 2 => [2 echo]
    |=> 3 echo
  """


  result = ResolverHelper resolve: #{"main" fileMain} entryPoint: "main"
  db = result db
  typedAst = result fileToStatements at: "main", unpackOrPANIC  

  // typedAst first toTyped nivaType log
  typedAst debug
] 


resolveGenerics = [
  fileMain = """
    type Box x: T y: T
    // box = Box x: "sas" y: "42"


    Box(Int) sas -> Unit = [42]


    //Box sasat::T = [
    //  sasat inc
    //]

  """


  result = ResolverHelper resolve: #{"main" fileMain} entryPoint: "main"
  db = result db
  typedAst = result fileToStatements at: "main", unpackOrPANIC  

  

] 

