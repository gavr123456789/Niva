type Program
  io: IO_Container


type FilePath = String
type FileContent = String

type NivaSourceFile
  path: String
  nameWithoutExt: String

type IO_Container
  readFile:   [FilePath -> String]
  writeFile:  [FilePath, FileContent -> Unit]
  walkDir:    [FilePath -> List::NivaSourceFile]
  getParent:  [String -> String]
  currentDir: String
  runProgram: [List::String -> ]

constructor IO_Container new -> IO_Container = [
  readFile::[FilePath -> String] = [path::String ->
    FileSystem read: (path toPath)
  ]


  writeFile = [path::String , fileContent::FileContent ->
    FileSystem write: path toPath
               content: fileContent
    Unit
  ]

  walkDir::[FilePath -> List::NivaSourceFile] = [path::String ->
    x = FileSystem listRecursively: path toPath

    x map: [
      NivaSourceFile path: it toString nameWithoutExt: (it name substringBeforeLast: ".")
    ]
  ]

  getParent = [path::String -> path toPath parent unpackOrPANIC toString]

  runProgram = [args::List::String ->
    processBuilder = ProcessBuilder command: args
    processBuilder redirectOutput start waitFor
    Unit
  ]

  ^ IO_Container :readFile :writeFile :walkDir :getParent currentDir: "." :runProgram
]




compilerTry = [
  path = Compiler cliArgs debug //"~/Documents/Fun/niva_demo/main.niva"
  NivaCompiler runArgs: path withIO: IO_Container new
]

compilerTry2 = [
  path = {"run" ".niva_js/testss.niva"} //"~/Documents/Fun/niva_demo/main.niva"
  //t1 = System currentTimeMillis
  //t1 echo
  NivaCompiler runArgs: path withIO: IO_Container new
  //diff = System currentTimeMillis - t1
  //diff echo // 60 toLong / 1000 toLong, echo
]

pipesAgain = [

  input = """
    1 to: 2, to: 3
  """ trimIndent

  statements = TestParse withInput: input expectedCount: 1
  > statements at: 0
] do

// strange bug
//rarar = [
//  LexTest checkThat: "()"
//          equals: {
//                   TokenType.Comma
//                  }
//] do


genericsReceiverAndKwArg = [
  fileMain = """
    type Box x: T
    box = Box x: 42
    Box(T) tGeneric::T -> T = [
        ^ tGeneric
    ]
    res = box tGeneric: 1
  """

  result = ResolverHelper resolve: #{"main" fileMain} entryPoint: "main"
  db = result db
  typedAst = result entryPointExpressions

  boxDecl = typedAst at: 0
]

//"\n\n--------\n--------\n\n" echo

mapCollection = [
  fileMain = """
    {1 2 3} map: [it inc]
  """

  //result = ResolverHelper resolve: #{"main" fileMain} entryPoint: "main"
  result = fileMain resolveNivaCode

  db = result db
  typedAst = result entryPointExpressions

]

untypedArgsResolve = [
  fileMain = """
    // untyped args with expected type - map infers types from [Int -> Int]
    list = {1 2 3}
    doubled = list map: [x -> x * 2]
    tripled = list map: [x -> x inc inc inc]
    //[x: Int -> x inc inc inc]
  """

  result = fileMain resolveNivaCode
  db = result db
  typedAst = result entryPointExpressions
  last = typedAst last
  //last debug
  //Assert that: last typeInfo t name equals: "Int"
]

sas = [
  fileMain = """
    list map: [x -> x * 2]
    list map: [x -> x inc inc inc]
  """

  result = fileMain resolveNivaCode
  db = result db
  typedAst = result entryPointExpressions
  last = typedAst last
  //last debug
  //Assert that: last typeInfo t name equals: "Int"
]


codeBlockStatementWithNewSyntax = [
  input = """
    // call with args
    [x: Int, y: Int -> x + y] x: 1 y: 2
  """ trimIndent
  statements = TestParse withInput: input expectedCount: 1
  > statements
]



odin = [
  program = "+ + * ) - /"
  acc <- 0
  program forEach: [
    | it
    | '+' => acc <- acc inc
    | '-' => acc <- acc dec
    | '*' => acc <- acc * 2
    | '/' => acc <- acc / 2
    | ')'=> acc <- acc * acc
    |=> []
  ]
  "The program $program calculates the value $acc" echo
]
