type UnionTBranch name: String typeT: NivaType
type TypeTField name: String typeT: NivaType
TypeTField toString -> String = 
  "$name: $typeT"

/// no name provided
constructor TypeTField binary: t::NivaType = TypeTField name: "" typeT: t

union NivaType name: String pkgName: String = 
| UnitT
| IntegerT
| FloatT
| DoubleT
| BoolT
| CharT
| StringT
| AnyT
| NothingT
// complex
| TypeT  fields: mut List::TypeTField genericArgs: mut List::NivaType 
| UnionT  branches: List::UnionTBranch
| FuntionT args: List::TypeTField returnType: NivaType// method or lambda
// collections
| ListT t: NivaType
| SetT t: NivaType
| MapT k: NivaType v: NivaType
// utility
| UnresolvedGenericT letter: String
| NullT // usually x = null, should be resolved to x::Nothing = null
| NullableT v: NivaType
| Unknown // Special type for 

extend NivaType [
  on generateId -> String = [

    result = | this
    | TypeT => [
      genericArgsStr = genericArgs isNotEmpty 
                        ifTrue: ["(" + (genericArgs joinWith: "," transform: [it name]) + ")"] 
                        ifFalse: [""]
      
      pkgName + "." + name + genericArgsStr
    ]
    
    | UnresolvedGenericT => [name]
    | NullableT => [this v generateId + "?"]
    | Unknown => [TO DO: "Can't get id of Unknown type, all types should be resolved"]
    |=> [
      pkgName + "." + name 
    ]
    ^ result
  ]
]

constructor TypeT noFieldsWithName: name::String pkgName::String  = TypeT 
  :name :pkgName fields: {}! genericArgs: {}!

extend TypeT [
  on generateDefaultConstructor -> NivaMethod = 
    | fields isEmpty
    | true => [
      // new 
      
      NivaMethod constructorWithName: "new" args: {} returnType: this decl: null protocolName: "constructors" pkgName: this pkgName 
    ] 
    | false => [
      // each field
      constructorName = fields joinWith: ":" transform: [it name], + ":"
      NivaMethod constructorWithName: constructorName args: fields returnType: this decl: null protocolName: "constructors" pkgName: this pkgName 
    ]

  on collectGenerics -> List::NivaType = [
    genericFields = fields filter: [
      nivaType = it typeT
      | nivaType
      | UnresolvedGenericT => true
      |=> false
    ]
    
    set = #(String)!
    result = {NivaType}!
    genericFields forEach: [
      set contains: it typeT name, ifFalse: [
        set add: it typeT name
        result add: it typeT
      ]
    ]
    
    // result = genericFields map: [it name], toSet, map: [
    //    UnresolvedGenericT name: it
    // ]
    ^ result
  ]
  /// creates unique identificator
  on toIdString -> String = [
    genericStr = genericArgs map: [it name], sortedBy: [it], joinWith: " " transform: [it]
    ^ pkgName + "." + name + "<" + genericStr + ">"
  ] 
  
]


constructor UnresolvedGenericT name::String = UnresolvedGenericT name: name letter: name pkgName: "core"
constructor UnitT new    = UnitT    name: "Unit"    pkgName: "core"
constructor IntegerT new = IntegerT name: "Int" pkgName: "core"
constructor FloatT new   = FloatT   name: "Float"   pkgName: "core"
constructor DoubleT new  = DoubleT  name: "Double"  pkgName: "core"
constructor BoolT new    = BoolT    name: "Bool"    pkgName: "core"
constructor StringT new  = StringT  name: "String"  pkgName: "core"
constructor CharT new    = CharT    name: "Char"    pkgName: "core"

constructor AnyT new     = AnyT     name: "Any"     pkgName: "core"
constructor NothingT new = NothingT name: "Nothing" pkgName: "core"
constructor NullT new    = NullT    name: "Null"    pkgName: "core"
constructor Unknown new  = Unknown  name: "Unknown" pkgName: "core"

constructor ListT t::NivaType            = ListT t: t     name: "List" pkgName: "core"
constructor SetT t::NivaType             = SetT t: t      name: "Set"  pkgName: "core"
constructor MapT k::NivaType v::NivaType = MapT k: k v: v name: "Map"  pkgName: "core"

constructor NullableT v::NivaType = NullableT v: v name: v name pkgName: v pkgName


  // receiver: NivaType // not needed since we always getting it from type, which is already represent receiver
type NivaMethod 
  name: String 
  args: List::TypeTField
  returnType: NivaType
  forMut: Bool // can be called only on mutable types
  possibleErrors: List::UnionT
  kind: MessageSendKind
  decl: MessageDecl? // getters, default constructors(new and fields) and messages from Core pkg does not have decls
  protocolName: String
  pkgName: String

extend NivaMethod [
  on copyWithDifferentReturnType: rt::NivaType = 
    NivaMethod name: name args: args returnType: rt forMut: forMut possibleErrors: possibleErrors kind: kind decl: decl protocolName: protocolName pkgName: pkgName
  
  /// sort args and checks them with fields, so any arg order should work probably 
  on isConstructorForReceiver: receiver::TypeT -> Bool = [
    {fields} = receiver
    argsSorted = args map: [it name], sortedBy: [it], joinWith: ", "
    fieldsSorted = fields map: [it name], sortedBy: [it], joinWith: ", "
    ^ argsSorted == fieldsSorted
  ]
  on toString -> String = [
    isMut = forMut ifTrue: ["mut"] ifFalse: [""]
    possibleErrorsStr = (possibleErrors joinWith: ", " transform: [it name]) 
    p2 = possibleErrorsStr == "" ifTrue: [""] ifFalse: [" with possible errors: (" + possibleErrorsStr + ")!"]
    argsStr = args joinWith: " " transform: [it toString]    
    ^ isMut + name + argsStr + p2 + " -> " + returnType toString
  ]
]

constructor NivaMethod [
  /// Create CALL
  on name::String args::List::TypeTField returnType::NivaType forMut::Bool decl::MessageDecl? protocolName::String pkgName::String= NivaMethod 
    name: name 
    args: args
    returnType: returnType
    forMut: forMut
    possibleErrors: {}
    kind: MessageSendKind.Call
    decl: decl
    protocolName: protocolName
    pkgName: pkgName

  on name::String args::List::TypeTField returnType::NivaType forMut::Bool protocolName::String pkgName::String = NivaMethod 
    name: name 
    args: args
    returnType: returnType
    forMut: forMut
    possibleErrors: {}
    kind: MessageSendKind.Call
    decl: null
    protocolName: protocolName
    :pkgName

  on constructorWithName: name::String args::List::TypeTField returnType::NivaType decl::MessageDecl? protocolName::String pkgName::String-> NivaMethod = NivaMethod 
    name: name 
    args: args
    returnType: returnType
    forMut: false
    possibleErrors: {}
    kind: MessageSendKind.Constructor
    decl: decl
    protocolName: protocolName
    :pkgName

]

type NivaProtocol 
  name: String 
  methods: mut Map(String, NivaMethod)

constructor NivaProtocol [
  on common = NivaProtocol name: "common" methods: #{}!
  on constructors = NivaProtocol name: "constructors" methods: #{}!
  on name::String = NivaProtocol name: name methods: #{}!
]

extend NivaProtocol [
  on addMethod::NivaMethod = [
    methods at: addMethod name put: addMethod
  ]
]

type NivaPkg 
  name: String 
  types: mut Map(String, NivaType)
  protocols: mut Map(NivaType, mut List::NivaProtocol)
  constructorsProtocol: NivaProtocol
  imports: mut Set::String


constructor NivaPkg name::String = NivaPkg name: name types: #{}! protocols: #{}! constructorsProtocol: NivaProtocol constructors imports: #()!
extend NivaPkg [
  on addImport: pkgName::String = [
    pkgName != this name ifTrue: [
      "Imports: added import of $pkgName to $name pkg" log
      imports add: pkgName
    ]
  ]
] 


type DefaultTypesContainer 
  char: CharT
  int: IntegerT
  float: FloatT
  double: DoubleT
  str: StringT
  bool: BoolT
  nill: NullT
  unit: UnitT 
  // utils
  nothing: NothingT
  any: AnyT
  t: UnresolvedGenericT 
  // create collections
  list: ListT 
  map: MapT 
  set: SetT 

constructor DefaultTypesContainer new -> DefaultTypesContainer = [
  t = (UnresolvedGenericT name: "T")
  dtc = DefaultTypesContainer 
    char: CharT new 
    int: IntegerT new 
    float: FloatT new 
    double: DoubleT new 
    str: StringT new 
    bool: BoolT new 
    nill: NullT new 
    unit: UnitT new 
    nothing: NothingT new 
    any: AnyT new 
    t: t
    list: (ListT t: t) 
    map: (MapT k: t v: t) 
    set: (SetT t: t)
  ^ dtc
]


/// create basic types like String Int List
constructor NivaPkg core -> Tuple(NivaPkg, DefaultTypesContainer) = [
  dtc = DefaultTypesContainer new
  {char, int, float, double, str, bool, nill, unit, 
  // utils
  nothing, any,
  // T
  t,
  // collections
  list, map, set} = dtc

  // create Int Protocol
  intProtocol = NivaProtocol intArithmeticsFromDefaultTypes: dtc
  strProtocol = NivaProtocol stringFromDefaultTypes: dtc
  boolProtocol= NivaProtocol boolFromDefaultTypes: dtc
  anyProtocol = NivaProtocol anyFromDefaultTypes: dtc


  corePkg = NivaPkg name: "core" types: #{
    "Bool" bool
    "Unit" unit 
    "String" str
    "Int" int 
    "Float" float 
    "Dobule" double

    "Null" nill
    "Nothing" nothing 
    "Any" any

    "List" list 
    "Set" set 
    "Map" map 
  }! 
  protocols: #{
    int  ({intProtocol}!)
    str  ({strProtocol}!)
    bool ({boolProtocol}!)
    any  ({anyProtocol}!)
  }! 
  constructorsProtocol: NivaProtocol constructors
  imports: #()!
   

  ^ Tuple x: corePkg y: dtc
]




// -----

Project protocol: "toString"

TypeT toString -> String = [
  // TODO genericArgs
  strFields = fields joinWith: " " transform: [
    it name + ": " + it typeT toString
  ]
  strGenericArgs =  genericArgs joinWith: " " transform: [
    it name
  ]
  strGenerics2 = genericArgs isNotEmpty ifTrue: [" <$strGenericArgs> "] ifFalse: [""]
  ^ " Type(" + name + " " + strFields  + strGenerics2 +  ")"
]

IntegerT toString -> String = " Type(" + name + ")" 
StringT  toString -> String = " Type(" + name + ")"
FloatT   toString -> String = " Type(" + name + ")"
DoubleT  toString -> String = " Type(" + name + ")"
BoolT    toString -> String = " Type(" + name + ")"
UnitT    toString -> String = " Type(" + name + ")"
CharT    toString -> String = " Type(" + name + ")"
NullT    toString -> String = " Type(" + name + ")"
UnresolvedGenericT toString -> String = " Type(" + name + ")"
