type UnionTBranch name: String typeT: NivaType
type TypeTField name: String typeT: NivaType
TypeTField toString -> String =
  "$name: $typeT"

/// no name provided
constructor TypeTField binary(t): NivaType = TypeTField name: "" typeT: t

union NivaType name: String pkgName: String =
// complex
| ^Complex
| UnitT
| IntegerT
| FloatT
| DoubleT
| BoolT
| CharT
| StringT
| AnyT
| NothingT

// collections
| ListT t: NivaType
| SetT t: NivaType
| MapT k: NivaType v: NivaType
// utility
| UnresolvedGenericT letter: String
| NullT // usually x = null, should be resolved to x::Nothing = null
| NullableT v: NivaType
| Unknown // Special type for


union Complex
  name: String
  pkgName: String
  fields: mut List::TypeTField
  genericArgs: mut List::NivaType =
| TypeT
| FuntionT
  args: List::TypeTField
  returnType: NivaType // method or lambda
| UnionT  branches: List::UnionTBranch

extend NivaType [
  on generateId -> String = [

    result = | this
    | TypeT => [
      genericArgsStr = genericArgs isNotEmpty
                        ifTrue: ["(" + (genericArgs joinWith: "," transform: [it name]) + ")"]
                        ifFalse: [""]

      pkgName + "." + name + genericArgsStr
    ]

    | UnresolvedGenericT => [name]
    | NullableT => [this v generateId + "?"]
    | Unknown => [TO DO: "Can't get id of Unknown type, all types should be resolved"]
    |=> [
      pkgName + "." + name
    ]
    ^ result
  ]
  /// generate unique identifiers for instantiated types (Box__Int)
  on toMangledName -> String = [
    result = | this
    | TypeT => [
      genericArgsStr = genericArgs isNotEmpty
                        ifTrue: ["__" + (genericArgs joinWith: "_" transform: [it toMangledName])]
                        ifFalse: [""]
      // TODO check that its not core type
      pkgName + "_" + name + genericArgsStr
    ]
    | UnresolvedGenericT => [name]
    | NullableT => [this v toMangledName + "__Nullable"] // nullables not supported yet
    | Unknown => ["Unknown"]
    |=> [
      pkgName + "_" + name
    ]
    ^ result
  ]

  on instantiateFromTable(table): Map(String, NivaType) -> String = [

    result = | this
    | TypeT => [
      genericArgsStr = genericArgs isNotEmpty
                        ifTrue: ["(" + (genericArgs joinWith: "," transform: [it name]) + ")"]
                        ifFalse: [""]

      pkgName + "." + name + genericArgsStr
    ]

    | UnresolvedGenericT => [name]
    | NullableT => [this v generateId + "?"]
    | Unknown => [TO DO: "Can't get id of Unknown type, all types should be resolved"]
    |=> [
      pkgName + "." + name
    ]
    ^ result
  ]

  on findField(fieldName): String -> TypeTField? = [
    field = | this
            | Complex => fields find: [it name == fieldName]
            |=> null
    ^ field
  ]
]

constructor TypeT noFieldsWithName(name): String pkgName: String  = TypeT
  :name :pkgName fields: {}! genericArgs: {}!

extend TypeT [
  on generateDefaultConstructor -> NivaMethod =
    NivaMethod
      defaultConstructorWithName: (fields isEmpty ifTrue: ["new"]
                                                  ifFalse: [fields joinWith: ":"
                                                                   transform: [it name], + ":"])
      receiverType: this
      args: fields
      returnType: this
      decl: null
      protocolName: "constructors"
      pkgName: this pkgName



  on collectGenerics -> List::NivaType = [
    genericFields = fields filter: [
      nivaType = it typeT
      | nivaType
      | UnresolvedGenericT => true
      |=> false
    ]

    set = #(String)!
    result = {NivaType}!
    genericFields forEach: [
      set contains: it typeT name, ifFalse: [
        set add: it typeT name
        result add: it typeT
      ]
    ]

    // result = genericFields map: [it name], toSet, map: [
    //    UnresolvedGenericT name: it
    // ]
    ^ result
  ]
  /// creates unique identificator
  on toIdString -> String = [
    genericStr = genericArgs isNotEmpty
                        ifTrue: [ "<" + (genericArgs map: [it name], sortedBy: [it], joinWith: " " transform: [it]) + ">"]
                        ifFalse: [""]

    ^ pkgName + "." + name + genericStr
  ]

]


constructor UnresolvedGenericT name: String = UnresolvedGenericT name: name letter: name pkgName: "core"
constructor UnitT new    = UnitT    name: "Unit"    pkgName: "core"
constructor IntegerT new = IntegerT name: "Int" pkgName: "core"
constructor FloatT new   = FloatT   name: "Float"   pkgName: "core"
constructor DoubleT new  = DoubleT  name: "Double"  pkgName: "core"
constructor BoolT new    = BoolT    name: "Bool"    pkgName: "core"
constructor StringT new  = StringT  name: "String"  pkgName: "core"
constructor CharT new    = CharT    name: "Char"    pkgName: "core"

constructor AnyT new     = AnyT     name: "Any"     pkgName: "core"
constructor NothingT new = NothingT name: "Nothing" pkgName: "core"
constructor NullT new    = NullT    name: "Null"    pkgName: "core"
constructor Unknown new  = Unknown  name: "Unknown" pkgName: "core"

constructor ListT t::NivaType            = ListT t: t     name: "List" pkgName: "core"
constructor SetT t::NivaType             = SetT t: t      name: "Set"  pkgName: "core"
constructor MapT k::NivaType v::NivaType = MapT k: k v: v name: "Map"  pkgName: "core"

constructor NullableT v::NivaType = NullableT v: v name: v name pkgName: v pkgName


  // receiver: NivaType // not needed since we always getting it from type, which is already represent receiver
type NivaMethod
  name: String
  receiverType: NivaType
  args: List(TypeTField)
  returnType: NivaType
  forMut: Bool // can be called only on mutable types
  possibleErrors: List(UnionT)
  kind: MessageSendKind
  decl: MessageDecl? // getters, default constructors(new and fields) and messages from Core pkg does not have decls
  protocolName: String
  pkgName: String

extend NivaMethod [
  on getGenericArgs =
    args filter: [
      | it typeT
      | UnresolvedGenericT => true
      |=> false
    ]


  on replaceGenericsFromTable(letterToType): Map(String, NivaType) dontMangle: Set(String) mangle: Bool db: TyperDB -> NivaMethod = [

    recType = receiverType
    retType = returnType

    instantiate = [ t::NivaType ->
      | t
      | TypeT => [
        db addGenericInstantiationIfAbsent: t
           letterToType: letterToType
      ]
      | UnresolvedGenericT => [
          maybe = letterToType at: t name
          | maybe
          | null => t
          |=> maybe
      ]
      |=> [t]
    ]
    instantiatedReceiverOrDefaultT = instantiate t: recType
    instantiatedReturnOrDefaultT = instantiate t: retType

    newArgs = args map: [
      TypeTField name: it name
                typeT: (instantiate t: it typeT)
    ]

    // instantiating the receiver does not change the method name:
    // the backend combines the receiverâ€™s mangled name with the method name

    // if the method itself has generics, the method name must include concrete types
    // tGeneric -> tGeneric__String

    methodGenericArgs = .getGenericArgs
    genericsToMangle = methodGenericArgs filter: [
         dontMangle contains: it typeT name, not
    ]

    newMethodName = (mangle and: genericsToMangle isNotEmpty)
      ifTrue: [
        genericMangled = genericsToMangle map: [
          // find what this generic arg resolves to
          resolvedType = letterToType at: it typeT name
          | resolvedType
          | null => [
             // if not resolved then its probably generic of the receiver, so we ignore it here
             // or its an error xddd
             ""
          ]
          |=> resolvedType toMangledName
        ]

        name + "__" + (genericMangled joinWith: "_")
      ]
      ifFalse: [name]



    ^ NivaMethod
        name: newMethodName
        receiverType: instantiatedReceiverOrDefaultT
        args: newArgs
        returnType: instantiatedReturnOrDefaultT
        :forMut
        :possibleErrors
        :kind
        :decl
        :protocolName
        :pkgName
  ]

  on copyWithDifferentReturnType(rt): NivaType =
    NivaMethod :name  :receiverType :args returnType: rt :forMut :possibleErrors :kind :decl :protocolName :pkgName

  /// sort args and checks them with fields, so any arg order should work probably
  on isConstructorForReceiver(receiver): TypeT -> Bool = [
    {fields} = receiver
    argsSorted = args map: [it name], sortedBy: [it], joinWith: ", "
    fieldsSorted = fields map: [it name], sortedBy: [it], joinWith: ", "
    ^ argsSorted == fieldsSorted
  ]
  on toString -> String = [
    isMut = forMut ifTrue: ["mut"] ifFalse: [""]
    possibleErrorsStr = (possibleErrors joinWith: ", " transform: [it name])
    p2 = possibleErrorsStr == "" ifTrue: [""] ifFalse: [" with possible errors: (" + possibleErrorsStr + ")!"]
    argsStr = args joinWith: " " transform: [it toString]
    ^ "NivaMethod " + isMut + " name: " +  name + "\nargs: (" + argsStr + ")" + p2 + "\n -> \n" + returnType toString
  ]
]

constructor NivaMethod [
  /// Create CALL
  on name: String receiverType: NivaType args: List::TypeTField returnType: NivaType forMut: Bool decl: MessageDecl? protocolName: String pkgName: String = NivaMethod
    name: name
    receiverType: receiverType
    args: args
    returnType: returnType
    forMut: forMut
    possibleErrors: {}
    kind: MessageSendKind.Call
    decl: decl
    protocolName: protocolName
    pkgName: pkgName

  on name::String receiverType::NivaType args::List::TypeTField returnType::NivaType forMut::Bool protocolName::String pkgName::String = NivaMethod
    name: name
    :receiverType
    args: args
    returnType: returnType
    forMut: forMut
    possibleErrors: {}
    kind: MessageSendKind.Call
    decl: null
    protocolName: protocolName
    :pkgName

  on defaultConstructorWithName(name): String receiverType: NivaType args: List(TypeTField) returnType: NivaType decl: MessageDecl? protocolName::String pkgName::String-> NivaMethod = NivaMethod
    :name
    :receiverType
    :args
    :returnType
    forMut: false
    possibleErrors: {}
    kind: MessageSendKind.DefaultConstructor
    :decl
    :protocolName
    :pkgName

]

type NivaProtocol
  name: String
  methods: mut Map(String, NivaMethod)

constructor NivaProtocol [
  on common = NivaProtocol name: "common" methods: #{}!
  on constructors = NivaProtocol name: "constructors" methods: #{}!
  on name: String = NivaProtocol name: name methods: #{}!
]

extend NivaProtocol [
  on addMethod::NivaMethod = [
    methods at: addMethod name put: addMethod
  ]
]

type NivaPkg
  name: String
  types: mut Map(String, NivaType)
  constructorsProtocol: NivaProtocol
  imports: mut Set::String


constructor NivaPkg name::String = NivaPkg name: name types: #{}! constructorsProtocol: NivaProtocol constructors imports: #()!
extend NivaPkg [
  on addImport(pkgName): String = [
    pkgName != this name ifTrue: [
      "Imports: added import of $pkgName to $name pkg" log
      imports add: pkgName
    ]
  ]
]


type DefaultTypesContainer
  char: CharT
  int: IntegerT
  float: FloatT
  double: DoubleT
  str: StringT
  bool: BoolT
  nill: NullT
  unit: UnitT
  // utils
  nothing: NothingT
  any: AnyT
  t: UnresolvedGenericT
  // create collections
  list: ListT
  map: MapT
  set: SetT

constructor DefaultTypesContainer new -> DefaultTypesContainer = [
  t = (UnresolvedGenericT name: "T")
  dtc = DefaultTypesContainer
    char: CharT new
    int: IntegerT new
    float: FloatT new
    double: DoubleT new
    str: StringT new
    bool: BoolT new
    nill: NullT new
    unit: UnitT new
    nothing: NothingT new
    any: AnyT new
    t: t
    list: (ListT t: t)
    map: (MapT k: t v: t)
    set: (SetT t: t)
  ^ dtc
]


/// create basic types like String Int List
constructor NivaPkg core -> Tuple(NivaPkg, DefaultTypesContainer) = [
  dtc = DefaultTypesContainer new
  {char, int, float, double, str, bool, nill, unit,
  // utils
  nothing, any,
  // T
  t,
  // collections
  list, map, set} = dtc

  corePkg = NivaPkg name: "core" types: #{
    "Bool" bool
    "Unit" unit
    "String" str
    "Int" int
    "Float" float
    "Dobule" double

    "Null" nill
    "Nothing" nothing
    "Any" any

    "List" list
    "Set" set
    "Map" map
  }!

  constructorsProtocol: NivaProtocol constructors
  imports: #()!


  ^ Tuple x: corePkg y: dtc
]




// -----

Project protocol: "toString"

TypeT toString -> String = [
  // TODO genericArgs
  strFields = fields joinWith: " " transform: [
    it name + ": " + it typeT toString
  ]
  strGenericArgs =  genericArgs joinWith: " " transform: [
    it name
  ]
  strGenerics2 = genericArgs isNotEmpty ifTrue: [" <$strGenericArgs> "] ifFalse: [""]
  ^ " Type(" + name + " " + strFields  + strGenerics2 +  ")"
]

IntegerT toString -> String = " Type(" + name + ")"
StringT  toString -> String = " Type(" + name + ")"
FloatT   toString -> String = " Type(" + name + ")"
DoubleT  toString -> String = " Type(" + name + ")"
BoolT    toString -> String = " Type(" + name + ")"
UnitT    toString -> String = " Type(" + name + ")"
CharT    toString -> String = " Type(" + name + ")"
NullT    toString -> String = " Type(" + name + ")"
AnyT    toString -> String = " Type(" +  name + ")"
ListT    toString -> String = " Type(" + name + " <" + t toString + ">" + ")"
MapT    toString -> String = " Type(" +  name + " <" + "key: $k val: $v" +  ">" + ")"
SetT    toString -> String =  " Type(" + name + " <" + t toString + ">" + ")"
UnresolvedGenericT toString -> String = " Type(" + name + ")"
