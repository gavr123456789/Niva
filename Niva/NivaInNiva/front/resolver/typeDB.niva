type TyperDB 
  // setOfTypeNames: mut Set::String
  listOfErrors: mut List::ResolveErrors
  listOfDeclaredTypes: mut List::TypeT

  packages: mut Map(String, NivaPkg)


  // caches
  internalTypesCache: mut Map(String, NivaType) // types from Core pkg
  typesWithSameNames: mut Map(String, mut Set::NivaType)

  typesWithResolvedGenerics: mut Map(String, TypeT) // typeID("pkg.Map.Ing.String") to type, why not type to type, because we need real generic info
  // utils
  dtc: DefaultTypesContainer

  


constructor TyperDB new -> TyperDB = [
  // for now I wont add core types to typesWithSameNames db
  // just inside search method check if its name from core, then return from core cache
  tuple = NivaPkg core
  corePkg = tuple x
  dtc = tuple y
  

  ^TyperDB 
    // setOfTypeNames: #()! 
    listOfErrors: {}!
    listOfDeclaredTypes: {}!
    packages: #{"core" corePkg}!
    internalTypesCache: corePkg types
    typesWithSameNames: #{}!
    typesWithResolvedGenerics: #{}!
    dtc: dtc
]

extend TyperDB [
  /// returns md like documentation about every pkg -> type -> protocol -> method
  on structureInfo -> String = [
    sb = StringBuilder new
    packages values filter: [it name != "core"], forEach: [ pkg -> 
      
      sb appendLine: "# pkg: " + pkg name

      pkg imports count != 0, ifTrue: [
        importsStr = pkg imports toList joinWith: ", "
        sb appendLine: "- uses: " + importsStr
      ]

      pkg protocols forEach: [t, protocolsOfType ->
        sb appendLine: "## type: " + t toString

        protocolsOfType forEach: [protocol -> 
          sb appendLine: "### protocol: " + protocol name

          protocol methods values forEach: [ method -> 
            sb appendLine: "- " + method toString
          ]
        ]
      ]
      // if no protocols, types would't be printed
      pkg protocols isEmpty ifTrue: [
        x = pkg types keys toList joinWith: "\n" transform: ["## type: " + it]
        sb appendLine: x
      ]
      
    ]

    ^ sb toString
  ]
]

type ResolverHelper
  fileToStatements: Map(String, List::Statement)  // по сути это список аст деклараций типов и методов, в которых боди теперь типизированы
  db: TyperDB
  entryPointExpressions: List::TypedExpr2
  // entryPointStatements: List::TypedExpr


// 1 выделить экспрешоны являющиеся мейн функцией из списка стейтментов ентри поинта
constructor ResolverHelper resolve: fileToContent::Map(String, String) entryPoint::String -> ResolverHelper  = [
  fileToStatements::mut Map(String, List::Statement) = #{}!
  
  // parsing
  fileToContent forEach: [ file, content ->
    statements = TestParse withInput: content expectedCount: -1
    fileToStatements at: file put: statements
  ]
   
  entryPointStatementsMaybe = fileToStatements at: entryPoint
  entryPointStatements = 
    | entryPointStatementsMaybe
    | null => [TO DO: "trying to find entryPoint: " + entryPoint + " but not found in " + fileToStatements toString]
    |=> [ entryPointStatementsMaybe ]

  db = TyperDB new

  msgDecls = TypeDeclVisitor db: db, 
    visitAllTypesThenTypesAndMethods: fileToStatements
    entryPointStatements: entryPointStatements


  // find main and replace statements from fileToStatements with typed
  // да просто стейтменты ентри поинта отдельно класть в резалте
  // fileToStatements 
  //   at: "entryPoint" 
  //   put: (msgDecls find: [it x == "entryPoint"], unpackOrPANIC) y body typedBody2 // todo


  MsgDeclVisitor new
    processBodyes: msgDecls 
    db: db
     
  ^ ResolverHelper 
    fileToStatements: fileToStatements 
    db: db
    entryPointExpressions: (msgDecls find: [it x == "entryPoint"], unpackOrPANIC) y body typedBody2
]


Project protocol: "adding"


/// adds method to protocol, if no such protocol - creates it
NivaPkg addMethod: m::NivaMethod toProtocol: protocolName::String forType::NivaType= [
  // find type to protocols list or create a new list with new protocol
  // find new protocol in a list or create a new protocol
  // add method to protocol

  createNewProtocol = [
    newProtocol = NivaProtocol name: protocolName
    newProtocol addMethod: m
    newProtocol  
  ]
  
  foundProtocols = protocols at: forType
  | foundProtocols
  | null => [
    newProtocol = createNewProtocol do
    protocols at: forType put: {newProtocol}!
    "Methods: added method " + m name + " to new protocol $protocolName for type $forType in pkg ", log
  ]
  |=> [
    protocol = foundProtocols find: [it name == protocolName]
    | protocol
    | null => [
      // no such protocol -> create it
      newProtocol = createNewProtocol do
      foundProtocols add: newProtocol
      "Methods: added method " + m name + " to new protocol $protocolName", log
    ]
    |=> [
      protocol addMethod: m
      "Methods: added method " + m name + " to protocol $protocolName", log
    ]  
  ]

]

/// adds ne method for db, if protocol is null then adds to "common"
TyperDB addNewMethod: m::NivaMethod forType::NivaType inProtocol::String? = [
  pkg = packages at: forType pkgName
  | pkg 
  | null => TO DO: "no pkg"
  |=> pkg 
        addMethod: m 
        toProtocol: (inProtocol unpackOrValue: "common") 
        forType: forType
]

TyperDB addErrorMessage: e::ResolveErrors = [
  msg = e msg
  "ADDED ERROR $msg" red log
  listOfErrors add: e
]

TyperDB printAllErrorMessages = [
  fakeFilePath = "main.niva"
  listOfErrors forEach: [
    tokStart = it tok start toString
    tokLine = it tok line toString

    "Error: ($fakeFilePath.$tokLine.$tokStart)" red + it msg cyan,
      echo
  ]
]

TyperDB addNewConstructor: m::NivaMethod forType::NivaType = [

  Assert that: m kind equals: MessageSendKind.Constructor andSay: "add New Constructor, but its kind is " + m kind toString
  pkg = packages at: forType pkgName
  | pkg 
  | null => TO DO: "no pkg"
  |=> [
    pkg constructorsProtocol addMethod: m
    "Constructors: added constructor " + m name + " for type " + forType name, log
  ]

]

TyperDB addNewPkgIfNotExists: pkgName::String -> NivaPkg = [
  result = packages at: pkgName
  p = | result
      | null => [
        newPkg = NivaPkg name: pkgName
        packages at: pkgName put: (newPkg)
        newPkg
      ]
      |=> [
        result 
      ]

  ^ p
]

TyperDB addNewType: t::TypeT inPkg: pkgName::String = [
  // 1 add to pkg
  // find the pkg
  pkg = packages at: pkgName
  | pkg
  | null => TO DO: "Compiler bug: cant find pkg $pkgName"
  |=> [
    pkg types at: t name put: t
  ]

  setMaybe = typesWithSameNames at: t name

  | setMaybe
  | null => [
    // create set
    newSet::mut Set::NivaType = #()!
    newSet add: t
    typesWithSameNames at: t name put: newSet
  ]
  |=> [
    // add type to set
    setMaybe add: t
  ]
]

TyperDB addGenericInstantiationIfAbsent: t::TypeT letterToType::Map(String, NivaType) -> TypeT = [
  newTypeWithGenericInstantiated = t replaceGenericsFromTable: letterToType
  typeId = newTypeWithGenericInstantiated toIdString
  // check if it already 
  typesWithResolvedGenerics at: typeId, unpack: [
    "already resolved generic $typeId" log
     ^it 
  ]

  typesWithResolvedGenerics at: typeId put: newTypeWithGenericInstantiated
  "added new generic instantiation $typeId" log

  ^ newTypeWithGenericInstantiated
]

TypeT replaceGenericsFromTable: letterToType::Map(String, NivaType) -> TypeT = [
  newFields = fields map: [
    TypeTField name: it name 
               typeT: [
                  maybe = letterToType at: it typeT name
                  | maybe
                  | null => it typeT
                  |=> maybe 
               ] do
  ]

  newGenericArgs = genericArgs map: [
    maybe = letterToType at: it name
    | maybe
    | null => it
    |=> maybe 
  ]

  ^TypeT fields: newFields toMutableList 
         genericArgs: newGenericArgs toMutableList 
         :name :pkgName 
]

NivaPkg replaceMethod: m::NivaMethod inType::NivaType= [
  protocols2 = protocols at: inType, unpackOrPANIC
  foundProtocol = protocols2 find: [ proto ->
    proto name == m protocolName
  ], unpackOrPANIC
  
  foundProtocol methods at: m name put: m 
]

Project protocol: "finding"

// добавить в NivaPkg список методов из других пакетов, точнее даже мапа
// методНейм - пкг, нет, тк кк в разных пакетах могут быть одинаковые методы
// как ни крути походу лучше всего хранить пакет в самом методе

NivaPkg findMethodInAllProtocols: name::String forType::NivaType receiver::TypedExpr2 currentPkg::NivaPkg -> NivaMethod = [


  receiver isIdentifierConstructor ifTrue: [
    maybeConstructor = constructorsProtocol methods at: name
    | maybeConstructor
    | null => [TO DO: "No such constructor $name for type $forType"]
    |=> [
      // currentImports add: ""
      
      currentPkg addImport: maybeConstructor pkgName
      
      "Constructors: found constructor $name for $forType" log
      ^ maybeConstructor 
    ]
  ]

  protocols = protocols at: forType
  | protocols
  | null => [TO DO: "Searching for $name method but type $forType has zero protocols"]
  |=> [ 

    protocols forEach: [ p -> 
      method = p methods at: name
      | method 
      | null => [
        // knownMethods add: name
        null
      ]
      |=> [
        currentPkg addImport: method pkgName
        ^ method]
    ]
  ]

  typeName = forType name
  TO DO: "Searching for $name method but its not found for type $typeName"
]

TyperDB 
  findMsgFromReceiver: receiver::TypedExpr2 
  byName: name::String 
  currentPkg::NivaPkg -> NivaMethod = [
  
  receiverType = receiver typeInfo t

  | receiverType
  | FuntionT => [
    // check that its Do or any arg names 
    result = name == "do" ifTrue: [
      NivaMethod unary: "do" returnT: receiverType returnType
    ] ifFalse: [TO DO]
    
    ^ result
  ]
  |=> []
  pkg = packages at: receiverType pkgName, unpackOrPANIC
  method = pkg findMethodInAllProtocols: name forType: receiverType :receiver currentPkg: currentPkg
  
 ^| method returnType
  | Unknown => [
    "Lazy resolving for $name", log

    {decl} = method
    | decl
    | null => TO DO: "Compiler bug, only single expr methods can have Unknown method, and they should have decl defined"
    |=> [
      Assert that: decl isSingleExpr equals: true

  
      decl resolveBodyWithDb: this pkg: pkg

      Assert that: decl body typedBody2 isNotEmpty equals: true

      returnType = decl body typedBody2 last typeInfo t

      replaceMethod = method copyWithDifferentReturnType: returnType
      pkg replaceMethod: replaceMethod inType: receiverType
      replaceMethod returnType debug
      replaceMethod
    ]
  ]
  |=> method

  // ^ method
] 

TyperDB 
  findByTypeName: typeName::String = .findByTypeName: typeName inPkg: null


TyperDB 
  findByTypeName: typeName::String 
  inPkg: pkgName::String? -> NivaType = [

  
  typeName isGeneric ifTrue: [
    ^ UnresolvedGenericT name: typeName
  ]

  // if core return from cache 
  internalType = internalTypesCache at: typeName
  | internalType
  | null => []//TO DO: "internal type: $typeName is not in core pkg" // compiler bug, not user error, so token wont be needed
  |=> [^ internalType 
        Unit]

  // its not core type
  // so use typesWithSameNames
  
  result = | pkgName
  | null => [
    // we dont know the pkg, so search type in every pkg
    sameNameType = typesWithSameNames at: typeName
    knownNames = typesWithSameNames keys
    | sameNameType
    | null => TO DO: "Bug: Cant find type $typeName in typesWithSameNames, known: $knownNames"
    |=> [
      | sameNameType count == 1
      | true => [
        // found only one type in the pkg
        ^ sameNameType first
      ]
      | false => TO DO: "There are many types with the same name: $sameNameType, please specify pkg like pkg.type"
    ]
  ]
  |=> [
    // we know the pkg, so search for type in it
    pkg = packages at: pkgName
    | pkg
    | null => [TO DO: "No such package as $pkgName, known pkgs: $packages"]
    |=> [
      foundType = pkg types at: typeName
      | foundType
      | null => [TO DO: "No such type: $typeName in $pkgName"]
      |=> [
        ^ foundType
      ]
    ]
  ]
  ^ result
]

