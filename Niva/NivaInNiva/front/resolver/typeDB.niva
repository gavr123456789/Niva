type TyperDB
  // setOfTypeNames: mut Set::String
  listOfErrors: mut List::ResolveErrors
  listOfDeclaredTypes: mut List::TypeT

  packages: mut Map(String, NivaPkg)


  // caches
  internalTypesCache: mut Map(String, NivaType) // types from Core pkg
  typesWithSameNames: mut Map(String, mut Set::NivaType)

  typesById: mut Map(String, TypeT) // typeID("pkg.Map.Ing.String") to type, why not type to type, because we need real generic info
  // utils
  dtc: DefaultTypesContainer
  // methods
  typeToMethodNameToMethod: mut Map(NivaType, mut Map(String, NivaMethod)) // methodDB
  constructorsTypeToMethodNameToMethod: mut Map(NivaType, mut Map(String, NivaMethod)) // constructorsDB
  instantiatedCache: mut Map(NivaType, mut Map(String, NivaMethod)) // From instantiated generics types like List(Int)

  // generated
  generatedMessageDecls: mut List::MessageDecl

  // local scope for generic resolution
  localGenericScope: mut Map(String, NivaType)





constructor TyperDB new -> TyperDB = [
  // for now I wont add core types to typesWithSameNames db
  // just inside search method check if its name from core, then return from core cache
  tuple = NivaPkg core
  corePkg = tuple x
  dtc = tuple y

  {char int float double str bool nill unit nothing any t list map set} = dtc


  listProtocol = NivaProtocol collectionFromDefaultTypes: dtc collectionType: list itemType: (UnresolvedGenericT name: "T")
  intProtocol  = NivaProtocol intArithmeticsFromDefaultTypes: dtc
  strProtocol  = NivaProtocol stringFromDefaultTypes: dtc
  boolProtocol = NivaProtocol boolFromDefaultTypes: dtc
  anyProtocol  = NivaProtocol anyFromDefaultTypes: dtc

  tempEmptyProto::mut Map(mut String, mut NivaMethod) = #{}!

  typeToMethodNameToMethod::mut Map(NivaType, mut Map(String, NivaMethod)) = #{
    char tempEmptyProto

    int intProtocol

    float tempEmptyProto
    double tempEmptyProto

    str strProtocol
    bool boolProtocol

    //nill
    unit tempEmptyProto

    any anyProtocol
    list listProtocol
    map tempEmptyProto
    set tempEmptyProto
  }

  constructorsCache::mut Map(NivaType, mut Map(String, NivaMethod)) = #{
    char tempEmptyProto
    int tempEmptyProto
    float tempEmptyProto
    double tempEmptyProto
    str tempEmptyProto
    bool tempEmptyProto
    //nill
    unit tempEmptyProto
    any tempEmptyProto
    list tempEmptyProto
    map tempEmptyProto
    set tempEmptyProto
  }

  typesWithSameNames::mut Map(String, mut Set::NivaType) = #{}!
  // add core types to typesWithSameNames so they can be found by mangled name (e.g. core_String)
  corePkg types values forEach: [
    mangled = it toMangledName
    set::mut Set::NivaType = #()!
    set add: it
    typesWithSameNames at: mangled put: set
  ]

  ^TyperDB
    listOfErrors: {}!
    listOfDeclaredTypes: {}!
    packages: #{"core" corePkg}!
    internalTypesCache: corePkg types
    typesWithSameNames: typesWithSameNames
    typesById: #{}!
    dtc: dtc
    typeToMethodNameToMethod: typeToMethodNameToMethod
    constructorsTypeToMethodNameToMethod: constructorsCache
    instantiatedCache: #{}!
    generatedMessageDecls: {}!
    localGenericScope: #{}!

]

extend TyperDB [
  on addGeneratedMessageDecl: m::MessageDecl = [
    generatedMessageDecls add: m
  ]
  /// adds method to protocol, if no such protocol - creates it
  on addMethod: m::NivaMethod toProtocol: protocolName::String forType::NivaType= [
    methodNameToMethodMap::mut Map(String, NivaMethod) = (typeToMethodNameToMethod at: forType) unpackOrPANIC
    methodNameToMethodMap containsKey: m name,
      ifTrue: [TO DO: "Type $forType already has method $m"]

    methodNameToMethodMap at: m name put: m
    m kind == MessageSendKind.Getter ifFalse: [
      "Methods: added method " + m name + " to new protocol $protocolName for type $forType in pkg ", log
    ]
  ]


  /// adds ne method for db, if protocol is null then adds to "common"
  on addNewMethod: m::NivaMethod forType::NivaType inProtocol::String? = [
    this
      addMethod: m
      toProtocol: (inProtocol unpackOrValue: "common")
      forType: forType
  ]

  on addErrorMessage: e::ResolveErrors = [
    msg = e msg
    "ADDED ERROR $msg" red log
    listOfErrors add: e
    //TO DO: "Error"
  ]

  on addErrorFromTok: tok::Token withMsg: msg::String = [
    "\n!!!!! ADDED ERROR $msg !!!!!\n" red log
    listOfErrors add: (LazyError :tok :msg)
  ]

  on addFatalErrorFromTok: tok::Token withMsg: msg::String = [
    "\n!!!!! ADDED ERROR $msg !!!!!\n" red log
    listOfErrors add: (LazyError :tok :msg)
    TO DO: "FATAL"
  ]

  on printAllErrorMessages = [
    fakeFilePath = "main.niva"
    listOfErrors forEach: [
      tokStart = it tok start toString
      tokLine = it tok line toString

      "Error: ($fakeFilePath.$tokLine.$tokStart)" red + it msg cyan,
        echo
    ]
  ]

  on addNewConstructor: m::NivaMethod forType::NivaType = [
    Assert that: m kind equals: MessageSendKind.DefaultConstructor andSay: "add New DefaultConstructor, but its kind is " + m kind toString

    x::mut Map(String, NivaMethod) = this constructorsTypeToMethodNameToMethod at: forType, unpackOrPANIC
    x at: m name put: m

    "addNewConstructor: added constructor " + m name + " for type " + forType name, log
  ]

  on addNewPkgIfNotExists: pkgName::String -> NivaPkg = [
    result = packages at: pkgName
    p = | result
        | null => [
          newPkg = NivaPkg name: pkgName
          packages at: pkgName put: (newPkg)
          newPkg
        ]
        |=> [
          result
        ]

    ^ p
  ]

  on addToTypesWithTheSameName: t::TypeT = [
    setMaybe = typesWithSameNames at: t name

    | setMaybe
    | null => [
      // create set
      newSet::mut Set::NivaType = #()!
      newSet add: t
      typesWithSameNames at: t name put: newSet
    ]
    |=> setMaybe add: t

  ]
  on addNewType: t::TypeT inPkg: pkgName::String = [
    // 1 add to pkg
    // find the pkg
    pkg = packages at: pkgName
    | pkg
    | null => TO DO: "Compiler bug: cant find pkg $pkgName"
    |=> pkg types at: t name put: t


    .addToTypesWithTheSameName: t

    // also add mangled name
    mangled = t toMangledName
    // we don't use addToTypesWithTheSameName because it uses t name
    setMaybe = typesWithSameNames at: mangled
    | setMaybe
    | null => [
      newSet::mut Set::NivaType = #()!
      newSet add: t
      typesWithSameNames at: mangled put: newSet
    ]
    |=> setMaybe add: t

    id = t toIdString
    typesById get: id orPut: [t]
    "addNewType typesById: added new type $t to typesById with id: $id" log


    // 2 add to methods db
    x = this typeToMethodNameToMethod at: t
    | x
    | null => [
      "addNewType: added new type $t to methods cache with 0 members" log
      this typeToMethodNameToMethod at: t put: #{}! // new type does't have any methods yet
    ] |=> TO DO: "Compiler bug: such type was already added to methodDB"

    // 3 to constructors
    xc = this constructorsTypeToMethodNameToMethod at: t
    | xc
    | null => [
      "addNewType: added new type $t to constructor cache with 0 members" log
      this constructorsTypeToMethodNameToMethod at: t put: #{}! // new type does't have any methods yet
    ] |=> TO DO: "Compiler bug: such type was already added to constructorsDB"
  ]

  on addGenericInstantiationIfAbsent: t::TypeT letterToType::Map(String, NivaType) -> TypeT = [
    newTypeWithGenericInstantiated = t replaceGenericsFromTable: letterToType db: this
    typeId = newTypeWithGenericInstantiated toIdString

    // check if it already
    typesById at: typeId, unpack: [
      "already resolved generic $typeId" log
      ^it
    ]

    typesById at: typeId put: newTypeWithGenericInstantiated
    "added new generic instantiation $typeId" log

    // add to lookup for mangled name (so we can find Box__Int)
    mangled = newTypeWithGenericInstantiated toMangledName
    // .addToTypesWithTheSameName: newTypeWithGenericInstantiated // this uses name, which is "Box"

    // manually add mangled name
    setMaybe = typesWithSameNames at: mangled
    | setMaybe
    | null => [
      newSet::mut Set::NivaType = #()!
      newSet add: newTypeWithGenericInstantiated
      typesWithSameNames at: mangled put: newSet
    ]
    |=> setMaybe add: newTypeWithGenericInstantiated


    // we adding type the first time, othervice it would be returned before
    Assert that: (instantiatedCache at: t) equals: null

    // add empty method lits to methods and constructors
    this instantiatedCache at: newTypeWithGenericInstantiated put: #{}!
    instMethods::mut Map(String, NivaMethod) = #{}!
    this typeToMethodNameToMethod at: newTypeWithGenericInstantiated put: instMethods
    instConstructors::mut Map(String, NivaMethod) = #{}!
    this constructorsTypeToMethodNameToMethod at: newTypeWithGenericInstantiated put: instConstructors

    // copy methods
    dontMangle = letterToType keys toSet
    methodsOfGeneric = this typeToMethodNameToMethod at: t
    | methodsOfGeneric
    | null => []
    |=> [
       methodsOfGeneric values forEach: [ m ->
          newM = m replaceGenericsFromTable: letterToType dontMangle: dontMangle db: this
          instMethods at: newM name put: newM
       ]
    ]

    // copy constructors
    constructorsOfGeneric = this constructorsTypeToMethodNameToMethod at: t
    | constructorsOfGeneric
    | null => []
    |=> [
       constructorsOfGeneric values forEach: [ m ->
          newM = m replaceGenericsFromTable: letterToType dontMangle: dontMangle db: this
          instConstructors at: newM name put: newM
       ]
    ]

    ^ newTypeWithGenericInstantiated
  ]

  /// we use this for replacing an old method with Unknown return type with new one with resolved rt
  on replaceMethod: m::NivaMethod inType::NivaType = [
    x::mut Map(String, NivaMethod) = typeToMethodNameToMethod at: inType, unpackOrPANIC
    x at: m name put: m
  ]


// FINDING

// добавить в NivaPkg список методов из других пакетов, точнее даже мапа
// методНейм - пкг, нет, тк кк в разных пакетах могут быть одинаковые методы
// как ни крути походу лучше всего хранить пакет в самом методе

  on findMethodInAllProtocols: name::String forType::NivaType receiver::TypedExpr2 currentPkg::NivaPkg dtc::DefaultTypesContainer -> NivaMethod? = [

    // constructorsTypeToMethodNameToMethod keys debug

    receiver isIdentifierConstructor ? [
      constructorDB = this constructorsTypeToMethodNameToMethod at: forType, unpackOrPANIC, at: name
      | constructorDB
      | null => [TO DO: "No such constructor $name for type $forType"]
      |=> [
        ^ constructorDB
      ]
    ]

    typeToMethodNameToMethod keys debug
    x = this typeToMethodNameToMethod at: forType
    y::mut Map(String, NivaMethod) =
      | x
      | null => [TO DO: "cant find type $forType in db typeToMethodNameToMethod"]
      |=> [ x ]

    "Methods: found method $name in $forType" log
    ^ y at: name
  ]

  on findMsgFromReceiver: receiver::TypedExpr2
    byName: name::String
    currentPkg::NivaPkg -> NivaMethod = [

    receiverType = receiver typeInfo t
    // resolve do if this is message for a codeblock
    | receiverType
    | FuntionT => [
      // check that its Do or any arg names
      result = name == "do" ifTrue: [
        NivaMethod unary: "do" receiverType: receiverType returnT: receiverType returnType
      ] ifFalse: [
        // check that it has args
        // then compare them
        receiverType debug

        receiverType args
        NivaMethod manyArgKw: receiverType args receiverType: receiverType returnT: receiverType returnType
    ]

      ^ result
    ]
    |=> []
    pkg = packages at: receiverType pkgName, unpackOrPANIC

    methodMaybe = this findMethodInAllProtocols: name forType: receiverType :receiver :currentPkg :dtc
    method =
      | methodMaybe
      | null => [
          {any} = dtc
          foundInAnyMaybe = this findMethodInAllProtocols: name forType: any :receiver :currentPkg :dtc
          | foundInAnyMaybe
          | null => [TO DO: "Searching for $name method but its not found for type $receiverType"]
          |=> foundInAnyMaybe
        ]
      |=> methodMaybe


    result =
      | method returnType
      | Unknown => [
        "Lazy resolving for $name", log

        {decl} = method
        | decl
        | null => TO DO: "Compiler bug, only single expr methods can have Unknown method, and they should have decl defined"
        |=> [
          Assert that: decl isSingleExpr equals: true


          decl resolveBodyWithDb: this pkg: pkg extraTypes: #{}!

          Assert that: decl body typedBody2 isNotEmpty equals: true

          returnType = decl body typedBody2 last typeInfo t

          methodToReplace = method copyWithDifferentReturnType: returnType
          this replaceMethod: methodToReplace inType: receiverType
          methodToReplace
        ]
      ]
      |=> method

    ^ result
  ]

  on findByTypeName: typeName::String = .findByTypeName: typeName inPkg: null


  on findByTypeName: typeName::String inPkg: pkgName::String? -> NivaType = [

    typeName isGeneric ifTrue: [
      ^ UnresolvedGenericT name: typeName
    ]

    // check local scope
    localGenericScope at: typeName, unpack: [
      ^ it
    ]

    // if core return from cache
    internalType = internalTypesCache at: typeName
    | internalType
    | null => []//TO DO: "internal type: $typeName is not in core pkg" // compiler bug, not user error, so token wont be needed
    |=> [^ internalType
          Unit]

    // its not core type
    // so use typesWithSameNames

    result = | pkgName
    | null => [
      // we dont know the pkg, so search type in every pkg
      sameNameType = typesWithSameNames at: typeName
      knownNames = typesWithSameNames keys
      | sameNameType
      | null => TO DO: "Bug: Cant find type $typeName in typesWithSameNames, known: $knownNames"
      |=> [
        | sameNameType count == 1
        | true => [
          // found only one type in the pkg
          ^ sameNameType first
        ]
        | false => TO DO: "There are many types with the same name: $sameNameType, please specify pkg like pkg.type"
      ]
    ]
    |=> [
      // we know the pkg, so search for type in it
      pkg = packages at: pkgName
      | pkg
      | null => [TO DO: "No such package as $pkgName, known pkgs: $packages"]
      |=> [
        foundType = pkg types at: typeName
        | foundType
        | null => [TO DO: "No such type: $typeName in $pkgName"]
        |=> [
          ^ foundType
        ]
      ]
    ]
    ^ result
  ]


// INFO

  /// returns md like documentation about every pkg -> type -> protocol -> method
  on structureInfo -> String = [
    sb = StringBuilder new
    packages values filter: [it name != "core"], forEach: [ pkg ->

      sb appendLine: "## pkg: " + pkg name

      pkg imports count != 0, ifTrue: [
        importsStr = pkg imports toList joinWith: ", "
        sb appendLine: "- uses: " + importsStr
      ]

      this typeToMethodNameToMethod forEach: [t, methodNameToMethod ->
        t pkgName == pkg name ifTrue: [
          sb appendLine: "### type: " + t toString
          methodNameToMethod values forEach: [ method ->
            sb appendLine: "- " + method toString
          ]
        ]

      ]

      // pkg protocols forEach: [t, protocolsOfType ->
      //   sb appendLine: "## type: " + t toString

      //   protocolsOfType forEach: [protocol ->
      //     sb appendLine: "### protocol: " + protocol name

      //     protocol methods values forEach: [ method ->
      //       sb appendLine: "- " + method toString
      //     ]
      //   ]
      // ]
      // if no protocols, types would't be printed
      // pkg protocols isEmpty ifTrue: [
      //   x = pkg types keys toList joinWith: "\n" transform: ["## type: " + it]
      //   sb appendLine: x
      // ]

    ]

    ^ sb toString
  ]
]

type ResolverHelper
  fileToStatements: Map(String, List::Statement)  // по сути это список аст деклараций типов и методов, в которых боди теперь типизированы
  db: TyperDB
  entryPointExpressions: List::TypedExpr2
  // entryPointStatements: List::TypedExpr


constructor ResolverHelper resolve: fileToContent::Map(String, String) entryPoint::String -> ResolverHelper  = [
  fileToStatements::mut Map(String, mut List::Statement) = #{}!

  // parsing
  fileToContent forEach: [ file, content ->
    statements = TestParse withInput: content expectedCount: -1
    fileToStatements at: file put: statements
  ]

  entryPointStatementsMaybe = fileToStatements at: entryPoint
  entryPointStatements =
    | entryPointStatementsMaybe
    | null => [TO DO: "trying to find entryPoint: " + entryPoint + " but not found in " + fileToStatements toString]
    |=> [ entryPointStatementsMaybe ]

  db = TyperDB new

  msgDecls = TypeDeclVisitor db: db,
    visitAllTypesThenTypesAndMethods: fileToStatements
    entryPointStatements: entryPointStatements


  // find main and replace statements from fileToStatements with typed
  // да просто стейтменты ентри поинта отдельно класть в резалте
  // fileToStatements
  //   at: "entryPoint"
  //   put: (msgDecls find: [it x == "entryPoint"], unpackOrPANIC) y body typedBody2 // todo


  MsgDeclVisitor new
    processBodyes: msgDecls
    db: db

  // add generated functions to fileToStatements
  db generatedMessageDecls forEach: [
    //mutList::mut List
    (fileToStatements at: entryPoint, unpackOrPANIC) add: it
  ]

  ^ ResolverHelper
    fileToStatements: fileToStatements
    db: db
    entryPointExpressions: (msgDecls find: [it x == "entryPoint"], unpackOrPANIC) y body typedBody2
]

TypeT replaceGenericsFromTable: letterToType::Map(String, NivaType) db::TyperDB -> TypeT = [
  instantiate = [ t::NivaType ->
    | t
    | TypeT => [
      db addGenericInstantiationIfAbsent: t
         letterToType: letterToType
    ]
    | UnresolvedGenericT => [
        maybe = letterToType at: t name
        | maybe
        | null => t
        |=> maybe
    ]
    |=> [t]
  ]

  newFields = fields map: [
    TypeTField name: it name
              typeT: (instantiate t: it typeT)
  ]

  newGenericArgs = genericArgs map: [
    instantiate t: it
  ]

  ^TypeT fields: newFields toMutableList
        genericArgs: newGenericArgs toMutableList
        :name :pkgName
]
