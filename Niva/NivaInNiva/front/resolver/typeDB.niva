type TyperDB
  // setOfTypeNames: mut Set::String
  listOfErrors: mut List::ResolveErrors
  listOfDeclaredTypes: mut List::TypeT

  packages: mut Map(String, NivaPkg)


  // caches
  internalTypesCache: mut Map(String, NivaType) // types from Core pkg
  typesWithSameNames: mut Map(String, mut Set::NivaType)

  typesById: mut Map(String, TypeT) // typeID("pkg.Map.Ing.String") to type, why not type to type, because we need real generic info
  // utils
  dtc: DefaultTypesContainer
  // methods
  typeToMethodNameToMethod: mut Map(NivaType, mut Map(String, NivaMethod)) // methodDB
  constructorsTypeToMethodNameToMethod: mut Map(NivaType, mut Map(String, NivaMethod)) // constructorsDB
  instantiatedCache: mut Map(NivaType, mut Map(String, NivaMethod)) // From instantiated generics types like List(Int)





constructor TyperDB new -> TyperDB = [
  // for now I wont add core types to typesWithSameNames db
  // just inside search method check if its name from core, then return from core cache
  tuple = NivaPkg core
  corePkg = tuple x
  dtc = tuple y

  {char int float double str bool nill unit nothing any t list map set} = dtc


  listProtocol = NivaProtocol collectionFromDefaultTypes: dtc collectionType: list itemType: (UnresolvedGenericT name: "T")
  intProtocol  = NivaProtocol intArithmeticsFromDefaultTypes: dtc
  strProtocol  = NivaProtocol stringFromDefaultTypes: dtc
  boolProtocol = NivaProtocol boolFromDefaultTypes: dtc
  anyProtocol  = NivaProtocol anyFromDefaultTypes: dtc

  tempEmptyProto::mut Map(mut String, mut NivaMethod) = #{}!

  typeToMethodNameToMethod::mut Map(NivaType, mut Map(String, NivaMethod)) = #{
    char tempEmptyProto
    
    int intProtocol

    float tempEmptyProto
    double tempEmptyProto

    str strProtocol
    bool boolProtocol

    //nill
    unit tempEmptyProto

    any anyProtocol
    list listProtocol
    map tempEmptyProto
    set tempEmptyProto
  }

  constructorsCache::mut Map(NivaType, mut Map(String, NivaMethod)) = #{
    char tempEmptyProto
    int tempEmptyProto
    float tempEmptyProto
    double tempEmptyProto
    str tempEmptyProto
    bool tempEmptyProto
    //nill
    unit tempEmptyProto
    any tempEmptyProto
    list tempEmptyProto
    map tempEmptyProto
    set tempEmptyProto 
  } 

  ^TyperDB
    listOfErrors: {}!
    listOfDeclaredTypes: {}!
    packages: #{"core" corePkg}!
    internalTypesCache: corePkg types
    typesWithSameNames: #{}!
    typesById: #{}!
    dtc: dtc
    typeToMethodNameToMethod: typeToMethodNameToMethod
    constructorsTypeToMethodNameToMethod: constructorsCache
    instantiatedCache: #{}!

]

extend TyperDB [
  /// adds method to protocol, if no such protocol - creates it
  on addMethod: m::NivaMethod toProtocol: protocolName::String forType::NivaType= [
    forType debug 
    typeToMethodNameToMethod keys debug
    methodNameToMethodMap::mut Map(String, NivaMethod) = (typeToMethodNameToMethod at: forType) unpackOrPANIC
    methodNameToMethodMap containsKey: m name,
      ifTrue: [TO DO: "Type $forType already has method $m"]

    methodNameToMethodMap at: m name put: m
    "Methods: added method " + m name + " to new protocol $protocolName for type $forType in pkg ",
      log
  ]


  /// adds ne method for db, if protocol is null then adds to "common"
  on addNewMethod: m::NivaMethod forType::NivaType inProtocol::String? = [
    this
      addMethod: m
      toProtocol: (inProtocol unpackOrValue: "common")
      forType: forType
  ]

  on addErrorMessage: e::ResolveErrors = [
    msg = e msg
    "ADDED ERROR $msg" red log
    listOfErrors add: e
    TO DO: "Error"
  ]

  on addErrorFromTok: tok::Token withMsg: msg::String = [
    "\n!!!!! ADDED ERROR $msg !!!!!\n" red log
    listOfErrors add: (LazyError :tok :msg)
  ]

  on addFatalErrorFromTok: tok::Token withMsg: msg::String = [
    "\n!!!!! ADDED ERROR $msg !!!!!\n" red log
    listOfErrors add: (LazyError :tok :msg)
    TO DO: "FATAL"
  ]

  on printAllErrorMessages = [
    fakeFilePath = "main.niva"
    listOfErrors forEach: [
      tokStart = it tok start toString
      tokLine = it tok line toString

      "Error: ($fakeFilePath.$tokLine.$tokStart)" red + it msg cyan,
        echo
    ]
  ]

  on addNewConstructor: m::NivaMethod forType::NivaType = [
    Assert that: m kind equals: MessageSendKind.DefaultConstructor andSay: "add New DefaultConstructor, but its kind is " + m kind toString

    x::mut Map(String, NivaMethod) = this constructorsTypeToMethodNameToMethod at: forType, unpackOrPANIC
    x at: m name put: m

    "Constructors: added constructor " + m name + " for type " + forType name, log
  ]

  on addNewPkgIfNotExists: pkgName::String -> NivaPkg = [
    result = packages at: pkgName
    p = | result
        | null => [
          newPkg = NivaPkg name: pkgName
          packages at: pkgName put: (newPkg)
          newPkg
        ]
        |=> [
          result
        ]

    ^ p
  ]

  on addToTypesWithTheSameName: t::TypeT = [
    setMaybe = typesWithSameNames at: t name

    | setMaybe
    | null => [
      // create set
      newSet::mut Set::NivaType = #()!
      newSet add: t
      typesWithSameNames at: t name put: newSet
    ]
    |=> setMaybe add: t

  ]
  on addNewType: t::TypeT inPkg: pkgName::String = [
    // 1 add to pkg
    // find the pkg
    pkg = packages at: pkgName
    | pkg
    | null => TO DO: "Compiler bug: cant find pkg $pkgName"
    |=> pkg types at: t name put: t
    

    .addToTypesWithTheSameName: t    

    typesById get: (t toIdString) orPut: [t]

    // 2 add to methods db
    x = this typeToMethodNameToMethod at: t
    | x
    | null => [
      "Types: added type $t to constructor cache" log
      this typeToMethodNameToMethod at: t put: #{}! // new type does't have any methods yet
    ]
    |=> TO DO: "Compiler bug: such type was already added to methodDB"
    
    // 3 to constructors
    xc = this constructorsTypeToMethodNameToMethod at: t
    | xc
    | null => [
      "Types: added type $t to constructor cache" log
      this constructorsTypeToMethodNameToMethod at: t put: #{}! // new type does't have any methods yet
    ]
    |=> TO DO: "Compiler bug: such type was already added to constructorsDB"
    

    // this typeToMethodNameToMethod at: t put:
  ]

  on addGenericInstantiationIfAbsent: t::TypeT letterToType::Map(String, NivaType) -> TypeT = [
    newTypeWithGenericInstantiated = t replaceGenericsFromTable: letterToType
    typeId = newTypeWithGenericInstantiated toIdString
    // typesById get: typeId orPut: [newTypeWithGenericInstantiated]
    // check if it already
    typesById at: typeId, unpack: [
      "already resolved generic $typeId" log
      ^it
    ]

    typesById at: typeId put: newTypeWithGenericInstantiated
    "added new generic instantiation $typeId" log


    // we adding type the first time, othervice it would be returned before
    Assert that: (instantiatedCache at: t) equals: null

    // add empty method lits to methods and constructors
    this instantiatedCache at: t put: #{}!
    this constructorsTypeToMethodNameToMethod at: t put: #{}!
    ^ newTypeWithGenericInstantiated
  ]

  /// we use this for replacing an old method with Unknown return type with new one with resolved rt
  on replaceMethod: m::NivaMethod inType::NivaType = [
    x::mut Map(String, NivaMethod) = typeToMethodNameToMethod at: inType, unpackOrPANIC
    x at: m name put: m
  ]


// FINDING

// добавить в NivaPkg список методов из других пакетов, точнее даже мапа
// методНейм - пкг, нет, тк кк в разных пакетах могут быть одинаковые методы
// как ни крути походу лучше всего хранить пакет в самом методе

  on findMethodInAllProtocols: name::String forType::NivaType receiver::TypedExpr2 currentPkg::NivaPkg dtc::DefaultTypesContainer -> NivaMethod? = [

    // constructorsTypeToMethodNameToMethod keys debug

    receiver isIdentifierConstructor ? [
      constructorDB = this constructorsTypeToMethodNameToMethod at: forType, unpackOrPANIC, at: name
      | constructorDB
      | null => [TO DO: "No such constructor $name for type $forType"]
      |=> [
        ^ constructorDB
      ]
    ]

    typeToMethodNameToMethod keys debug
    x = this typeToMethodNameToMethod at: forType
    y::mut Map(String, NivaMethod) =
      | x
      | null => [TO DO: "cant find type $forType in db typeToMethodNameToMethod"]
      |=> [ x ]

    "Methods: found method $name in $forType" log
    ^ y at: name
  ]

  on findMsgFromReceiver: receiver::TypedExpr2
    byName: name::String
    currentPkg::NivaPkg -> NivaMethod = [

    receiverType = receiver typeInfo t
    // resolve do if this is message for a codeblock
    | receiverType
    | FuntionT => [
      // check that its Do or any arg names
      result = name == "do" ifTrue: [
        NivaMethod unary: "do" receiverType: receiverType returnT: receiverType returnType
      ] ifFalse: [
        // check that it has args
        // then compare them
        receiverType debug

        receiverType args
        NivaMethod manyArgKw: receiverType args receiverType: receiverType returnT: receiverType returnType
    ]

      ^ result
    ]
    |=> []
    pkg = packages at: receiverType pkgName, unpackOrPANIC

    methodMaybe = this findMethodInAllProtocols: name forType: receiverType :receiver :currentPkg :dtc
    method =
      | methodMaybe
      | null => [
          {any} = dtc
          foundInAnyMaybe = this findMethodInAllProtocols: name forType: any :receiver :currentPkg :dtc
          | foundInAnyMaybe
          | null => [TO DO: "Searching for $name method but its not found for type $receiverType"]
          |=> foundInAnyMaybe
        ]
      |=> methodMaybe


    result =
      | method returnType
      | Unknown => [
        "Lazy resolving for $name", log

        {decl} = method
        | decl
        | null => TO DO: "Compiler bug, only single expr methods can have Unknown method, and they should have decl defined"
        |=> [
          Assert that: decl isSingleExpr equals: true


          decl resolveBodyWithDb: this pkg: pkg

          Assert that: decl body typedBody2 isNotEmpty equals: true

          returnType = decl body typedBody2 last typeInfo t

          methodToReplace = method copyWithDifferentReturnType: returnType
          this replaceMethod: methodToReplace inType: receiverType
          methodToReplace
        ]
      ]
      |=> method

    ^ result
  ]

  on findByTypeName: typeName::String = .findByTypeName: typeName inPkg: null


  on findByTypeName: typeName::String inPkg: pkgName::String? -> NivaType = [

    typeName isGeneric ifTrue: [
      ^ UnresolvedGenericT name: typeName
    ]

    // if core return from cache
    internalType = internalTypesCache at: typeName
    | internalType
    | null => []//TO DO: "internal type: $typeName is not in core pkg" // compiler bug, not user error, so token wont be needed
    |=> [^ internalType
          Unit]

    // its not core type
    // so use typesWithSameNames

    result = | pkgName
    | null => [
      // we dont know the pkg, so search type in every pkg
      sameNameType = typesWithSameNames at: typeName
      knownNames = typesWithSameNames keys
      | sameNameType
      | null => TO DO: "Bug: Cant find type $typeName in typesWithSameNames, known: $knownNames"
      |=> [
        | sameNameType count == 1
        | true => [
          // found only one type in the pkg
          ^ sameNameType first
        ]
        | false => TO DO: "There are many types with the same name: $sameNameType, please specify pkg like pkg.type"
      ]
    ]
    |=> [
      // we know the pkg, so search for type in it
      pkg = packages at: pkgName
      | pkg
      | null => [TO DO: "No such package as $pkgName, known pkgs: $packages"]
      |=> [
        foundType = pkg types at: typeName
        | foundType
        | null => [TO DO: "No such type: $typeName in $pkgName"]
        |=> [
          ^ foundType
        ]
      ]
    ]
    ^ result
  ]


// INFO

  /// returns md like documentation about every pkg -> type -> protocol -> method
  on structureInfo -> String = [
    sb = StringBuilder new
    packages values filter: [it name != "core"], forEach: [ pkg ->

      sb appendLine: "## pkg: " + pkg name

      pkg imports count != 0, ifTrue: [
        importsStr = pkg imports toList joinWith: ", "
        sb appendLine: "- uses: " + importsStr
      ]

      this typeToMethodNameToMethod forEach: [t, methodNameToMethod ->
        t pkgName == pkg name ifTrue: [
          sb appendLine: "### type: " + t toString
          methodNameToMethod values forEach: [ method ->
            sb appendLine: "- " + method toString
          ]
        ]

      ]

      // pkg protocols forEach: [t, protocolsOfType ->
      //   sb appendLine: "## type: " + t toString

      //   protocolsOfType forEach: [protocol ->
      //     sb appendLine: "### protocol: " + protocol name

      //     protocol methods values forEach: [ method ->
      //       sb appendLine: "- " + method toString
      //     ]
      //   ]
      // ]
      // if no protocols, types would't be printed
      // pkg protocols isEmpty ifTrue: [
      //   x = pkg types keys toList joinWith: "\n" transform: ["## type: " + it]
      //   sb appendLine: x
      // ]

    ]

    ^ sb toString
  ]
]

type ResolverHelper
  fileToStatements: Map(String, List::Statement)  // по сути это список аст деклараций типов и методов, в которых боди теперь типизированы
  db: TyperDB
  entryPointExpressions: List::TypedExpr2
  // entryPointStatements: List::TypedExpr


constructor ResolverHelper resolve: fileToContent::Map(String, String) entryPoint::String -> ResolverHelper  = [
  fileToStatements::mut Map(String, List::Statement) = #{}!

  // parsing
  fileToContent forEach: [ file, content ->
    statements = TestParse withInput: content expectedCount: -1
    fileToStatements at: file put: statements
  ]

  entryPointStatementsMaybe = fileToStatements at: entryPoint
  entryPointStatements =
    | entryPointStatementsMaybe
    | null => [TO DO: "trying to find entryPoint: " + entryPoint + " but not found in " + fileToStatements toString]
    |=> [ entryPointStatementsMaybe ]

  db = TyperDB new

  msgDecls = TypeDeclVisitor db: db,
    visitAllTypesThenTypesAndMethods: fileToStatements
    entryPointStatements: entryPointStatements


  // find main and replace statements from fileToStatements with typed
  // да просто стейтменты ентри поинта отдельно класть в резалте
  // fileToStatements
  //   at: "entryPoint"
  //   put: (msgDecls find: [it x == "entryPoint"], unpackOrPANIC) y body typedBody2 // todo


  MsgDeclVisitor new
    processBodyes: msgDecls
    db: db

  ^ ResolverHelper
    fileToStatements: fileToStatements
    db: db
    entryPointExpressions: (msgDecls find: [it x == "entryPoint"], unpackOrPANIC) y body typedBody2
]

TypeT replaceGenericsFromTable: letterToType::Map(String, NivaType) -> TypeT = [
  newFields = fields map: [
    TypeTField name: it name
              typeT: [
                  maybe = letterToType at: it typeT name
                  | maybe
                  | null => it typeT
                  |=> maybe
              ] do
  ]

  newGenericArgs = genericArgs map: [
    maybe = letterToType at: it name
    | maybe
    | null => it
    |=> maybe
  ]

  ^TypeT fields: newFields toMutableList
        genericArgs: newGenericArgs toMutableList
        :name :pkgName
]
