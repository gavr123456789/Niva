/// used only for resolving body insied expressions, not for resolve body from message declarations
Body resolveBody2: db::TyperDB withContext: upperContext::Context -> TypedBody = [
  // StackTrace get log
  // Compiler getPlace log

  c = Context fromParent: upperContext
  
  // [] nothing to resolve
  unTypedBody isEmpty ifTrue: [
    ^ TypedBody v: {} t: db dtc unit
  ]


  Assert that: typedBody2 isEmpty equals: true

  // stackOfVisited::mut Set::MessageDecl = #()
  listOfTypedExpr2 = unTypedBody map: [ expr ->
    typed = expr toTypedExprFromDb2: db withContext: c
    typeOfExpr = typed typeInfo t
    // check that type is not Unknown
    | typeOfExpr | Unknown => [
      TO DO: "Unknown type of expr is not possible $expr"
    ] |=> []
    // if it is, then go and resolve the body, with remembering stack

    typed
  ]

  typedBody2 addAll: listOfTypedExpr2
  unTypedBody clear

  Assert that: typedBody2 isNotEmpty equals: true
  Assert that: unTypedBody isEmpty equals: true

  ^ TypedBody v: listOfTypedExpr2 
              t: listOfTypedExpr2 last typeInfo t
]


Expr toTypedExprFromDb2: db::TyperDB withContext: c::Context -> TypedExpr2 = [

  // todo optimize by adding core pkg to the TyperDB
  result = | this
  | CharExpr    => CharExprT :token typeInfo: db dtc char toTypeInfoDefault
  | IntExpr     => IntExprT :token typeInfo: db dtc int toTypeInfoDefault
  | FloatExpr   => FloatExprT :token typeInfo: db dtc float toTypeInfoDefault
  | DoubleExpr  => DoubleExprT :token typeInfo: db dtc double toTypeInfoDefault
  | StringExpr  => StringExprT :token typeInfo: db dtc str toTypeInfoDefault
  | BooleanExpr => BooleanExprT :token typeInfo: db dtc bool toTypeInfoDefault
  | NullExpr    => NullExprT :token typeInfo: db dtc nothing toTypeInfoDefault
  // Identifier can be type itself like Unit
  | Identifier   => [

    varType = c lookupForVar: this name
    | varType
    | null => [
      // this identifier can be name of the type and just a constructor call  
      name first isUpperCase ifTrue: [
        q = db findByTypeName: name // TODO replace by findMaybe, and dont check for UpperCase
        
        IdentifierT :name :path :token typeInfo: q toTypeInfoDefault isNameOfTheType: true
        // TypedExpr nivaType: (TypeOfTheType v: q) exprAst: this
      ] ifFalse: [
        contextString = c allKnownVars        
        TO DO: "Cant find $this in the current context: \n$contextString"
      ]
    ]
    |=> IdentifierT :name :path :token typeInfo: varType toTypeInfoDefault isNameOfTheType: false
    
  ]
  | ExprInBrackets => [
    valueT = value toTypedExprFromDb2: db withContext: c 
    ExprInBracketsT value: valueT :token typeInfo: valueT typeInfo
  ]
  | ListLiteral    => [
    typedElements = elements resolveBody2: db withContext: c 
    // Compare all elements between each other
    TO DO: "ListLiteral to TypedExpr"]
  | SetLiteral     => [
    typedElements = elements resolveBody2: db withContext: c 
    TO DO: "SetLiteral to TypedExpr"]
  | MapLiteral     => TO DO: "MapLiteral to TypedExpr" 

  | UnaryMsg   => .resolveUnaryFromDb2: db withContext: c 
  | BinaryMsg  => [
    this args isEmpty, ifTrue: [TO DO: "Compiler bug: binary without args"]
    ^ .replaceArgsWithTypedfromDb2: db withContext: c 
  ]
  | KeywordMsg =>[ 
    this args isEmpty, ifTrue: [TO DO: "Compiler bug: keyword without args is like a single identifier"]
    ^ .resolveKeywordFromDb2: db withContext: c 
  ]

  | VarDeclaration  => [
    // "var decl " + c toString, log
    typedExpr = this value toTypedExprFromDb2: db withContext: c 
    // check that ast type is the same as declared
    this astType unpack: [
      // x::Int = "ars"
      nivaType = db findByTypeName: it name
      typedExpr typeInfo t compareWith: nivaType, ifFalse: [
        valName = name
        astTypeName = it name
        realTypeName = typedExpr typeInfo t name
        // TODO add it to error list
        TO DO: "Type declared for $valName is not equal for it's value type $astTypeName != $realTypeName"
      ]
    ]

    c defineVar: name withType: typedExpr typeInfo t

    VarDeclarationT 
      :name 
      value: typedExpr 
      :astType 
      :token 
      typeInfo: db dtc unit toTypeInfoDefault
    
  ]
  | Assign => AssignT :name value: (value toTypedExprFromDb2: db withContext: c) :token typeInfo: db dtc unit toTypeInfoDefault
  | DestructingAssign => DestructingAssignT :names value: (value toTypedExprFromDb2: db withContext: c) :token typeInfo: db dtc unit toTypeInfoDefault
  | ReturnStatement =>[ 
    valueT = value unpack: [expr -> expr toTypedExprFromDb2: db withContext: c] or: null
    returnType = 
      | valueT
      | null => db dtc unit
      |=> valueT typeInfo t

    ReturnStatementT value: valueT 
                     :token 
                     typeInfo: returnType toTypeInfoDefault
  ]

  | CodeBlock => [
    c = Context fromParent: c

    typeTFields = args map: [
      {name astType} = it
      t = astType toNivaTypefromDB: db inPkg: null
      c defineVar: name withType: t
      TypeTField name: name typeT: t
    ]


    
    typedBody2 = body resolveBody2: db withContext: c
    returnType = typedBody2 t

    name = args joinWith: ":" transform: [it astType name], + ":" 

   x = (FuntionT 
      args: typeTFields 
      returnType: returnType 
      name: name 
      pkgName: c currentPkg name) 

   
    
    CodeBlockT :args :untypedArgs 
      body: typedBody2 
      :token 
      typeInfo: (FuntionT 
                  args: typeTFields 
                  returnType: returnType 
                  name: name 
                  pkgName: c currentPkg name) toTypeInfoDefault
  ]
  | Match     => [

    // TODO exhaustivness for unions and bool and enums and nullMatching
    elseb = elseBranch // local smart cast


    subjectT = subject toTypedExprFromDb2: db withContext: c 
    elseBranchT = 
      | elseb
      | null => [null]
      |=> [
        elseb resolveBody2: db withContext: c
        elseb
      ] 
    
    // TODO infer common type between all branches
    mut matchType::NivaType = db dtc unit
    branchesT = branches map: [

      conditionsT = it conditions resolveBody2: db withContext: c
      bodyT = it body resolveBody2: db withContext: c
      
      matchType <- it body typedBody2 last typeInfo t

      MatchBranchT condition: (it condition toTypedExprFromDb2: db withContext: c) 
                   conditions: conditionsT
                   body: bodyT
    ]
    

    newAst = MatchT subject: subjectT branches: branchesT elseBranch: TO DO token: token typeInfo: matchType toTypeInfoDefault
    ^ newAst
  ]
  | TypedExpr => TO DO: "Compiler bug: Recursive check, $this already type checked"


  ^ result
]





type CheckMethodArg2 nivaType: NivaType expr: Expr argName: String

// both for binary and keywords
TyperDB checkRealArgs2::List::CheckMethodArg2 withExpectedArgs::List::TypeTField = [
  Assert that: checkRealArgs2 count equals: withExpectedArgs count

  withExpectedArgs forEachIndexed: [ i, it ->
    {nivaType, expr, argName} = checkRealArgs2 at: i 
    
    it typeT compareWith: nivaType, ifFalse: [
      expected = it typeT toString
      sended = nivaType toString
      exprStr = expr toString
      msg = "($sended != $expected) $expected expected, but $argName $exprStr is $sended"
      this addErrorMessage: (ErrorWrongArgType 
                              tok: expr token 
                              msg: msg)
    ]
  ]

]


KeywordMsg resolveKeywordFromDb2: db::TyperDB withContext: c::Context  -> KeywordMsgT = [
  receiverTypedExpr = receiver toTypedExprFromDb2: db withContext: c
  receiverType = receiverTypedExpr typeInfo t
  argTypesAndExprs :: mut List::CheckMethodArg2 = {}!

  
  // так стоп, а как мы храним кейворды? вмеесте с :, потому что в этой реализации мы не разделяем сообщения по видам в базе
  kwMsgDB = db 
    findMsgFromReceiver: receiverTypedExpr 
    byName: .getNameFromArgs
    currentPkg: c currentPkg 
  
  Assert that: kwMsgDB args count equals: args count

  letterToType::mut Map(String, NivaType) = #{}!

  typedArgs = args mapIndexed: [ i, kwArg -> 
    {name expr} = kwArg
    typedExpr = expr toTypedExprFromDb2: db withContext: c
    argTypesAndExprs add: (CheckMethodArg2 
                            nivaType: typedExpr typeInfo t 
                            expr: expr 
                            argName: name name)
    
    argTypeFromDb = kwMsgDB args at: i, typeT
    | argTypeFromDb | UnresolvedGenericT => [
      // Check if we already resolved same letter to different type
      letterToType at: argTypeFromDb letter, unpack: [ alreadyResolvedTo::NivaType ->
        alreadyResolvedTo compareWith: typedExpr typeInfo t, ifFalse: [
          l = argTypeFromDb letter
          to = typedExpr typeInfo t
          TO DO: "Cant resolve $l to $to, it was already resolved to $alreadyResolvedTo"
        ]
      ]
      
      letterToType 
        at: argTypeFromDb letter 
        put: typedExpr typeInfo t
    ] |=> []

    NameAndExprT name: name expr: typedExpr
  ]
  
  
  // try to find by id
  letterToType isNotEmpty ifTrue: [
    receiverTypedExpr isIdentifierConstructor ifTrue: [
      // GENERIC DEFAULT CONSTRUCTOR - register instantiated variant
      | receiverType
      | TypeT => [
          receiverTypedExpr isIdentifierConstructor ifTrue: [] ifFalse: []
          thisIsConstructor = kwMsgDB isConstructorForReceiver: receiverType
          thisIsConstructor ifTrue: [

            db addGenericInstantiationIfAbsent: receiverType
              letterToType: letterToType 
          ]

      ] |=> [
        TO DO: "generic constructor for usual receiver"

      ]
    ] ifFalse: [
      // GENERIC MESSAGE FOR OBJ - resolve generic method with true types
      TO DO: "GENERIC MESSAGE FOR OBJ"
    ]
  ]

  
  // do not check if they are generics
  db checkRealArgs2: argTypesAndExprs withExpectedArgs: kwMsgDB args 
  newKeyword = KeywordMsgT 
    args: typedArgs 
    kind: kwMsgDB kind 
    receiver: receiverTypedExpr 
    token: token 
    typeInfo: (TypeInfo 
    t: kwMsgDB returnType 
    isMut: kwMsgDB forMut) 
  ^ newKeyword
] 

// rework - instead of replacing - make the receiver typed
BinaryMsg replaceArgsWithTypedfromDb2: db::TyperDB withContext: c::Context -> BinaryMsgT = [ 
  receiverTypedExpr = receiver toTypedExprFromDb2: db withContext: c 

  typeOfReceiver = receiverTypedExpr typeInfo t
  mut lastType = typeOfReceiver
  mut lastReceiver = receiverTypedExpr

  typedArgs = args map: [ binary ->
    // 1 + (2 inc)
    // find the message
    // resolce type of arg
    // compare that found message has arg with same type
    binaryName = binary name name
    dbMsg = db findMsgFromReceiver: lastReceiver  byName: binaryName currentPkg: c currentPkg 

    (dbMsg args count != 1) ifTrue: [TO DO: "Compiler bug, binary $dbMsg args != 1 in db"]
    dbArg = dbMsg args first
    // resolve type of arg
    resolvedArg = binary expr toTypedExprFromDb2: db withContext: c


    (resolvedArg typeInfo t compareWith: dbArg typeT) ifFalse: [
      expected = dbMsg args first typeT
      butGot = resolvedArg typeInfo t
      currentBinary = lastType toString + " " + binaryName + " " 
      TO DO: "In binary $currentBinary arg of type $expected expected, but got $butGot"
    ]

    // create typed expr with return type of dbMsg in db message
    typed = resolvedArg

    lastType <- dbMsg returnType // 2 + 2 ^(Int)+ 2
    lastReceiver <- resolvedArg // 2 + ^2 + 2
    NameAndExprT name: binary name expr: resolvedArg
  ]

  //
  newBinaryT = BinaryMsgT 
    args: typedArgs 
    receiver: receiverTypedExpr 
    token: token 
    typeInfo: lastType toTypeInfoDefault
  ^ newBinaryT 
] 


UnaryMsg resolveUnaryFromDb2:  db::TyperDB withContext: c::Context -> UnaryMsgT = [
  resolvedReceiver = receiver toTypedExprFromDb2: db withContext: c
  typeOfReceiver = resolvedReceiver typeInfo t
  dbMsg = db findMsgFromReceiver: resolvedReceiver byName: selector name currentPkg: c currentPkg

  typeInfo = TypeInfo t: dbMsg returnType isMut: dbMsg forMut
  newUnary2 = UnaryMsgT 
    selector: selector 
    kind: dbMsg kind 
    receiver: resolvedReceiver 
    token: token 
    typeInfo: typeInfo

  ^ newUnary2
]