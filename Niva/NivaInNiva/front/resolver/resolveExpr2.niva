/// used only for resolving body insied expressions, not for resolve body from message declarations
Body resolveBody2: db::TyperDB withContext: upperContext::Context -> TypedBody = [
  // StackTrace get log
  // Compiler getPlace log

  c = Context fromParent: upperContext

  // [] nothing to resolve
  unTypedBody isEmpty ifTrue: [
    ^ TypedBody v: {} t: db dtc unit
  ]


  Assert that: typedBody2 isEmpty equals: true

  // stackOfVisited::mut Set::MessageDecl = #()
  listOfTypedExpr2 = unTypedBody map: [ expr ->
    typed = expr toTypedExprFromDb2: db withContext: c
    typeOfExpr = typed typeInfo t
    // check that type is not Unknown
    | typeOfExpr | Unknown => [
      TO DO: "Unknown type of expr is not possible $expr"
    ] |=> []
    // if it is, then go and resolve the body, with remembering stack

    typed
  ]

  typedBody2 addAll: listOfTypedExpr2
  unTypedBody clear

  Assert that: typedBody2 isNotEmpty equals: true
  Assert that: unTypedBody isEmpty equals: true

  ^ TypedBody v: listOfTypedExpr2
              t: listOfTypedExpr2 last typeInfo t
]

// returns the number of wrong type element, if all good returns null
NivaType compareWithMany: types::List::NivaType -> Int? = [
  types forEachIndexed: [i, it ->
    x = this compareWith: it
    x ifFalse: [
      ^ i
    ]
  ]
  ^ null
]

Expr toTypedExprFromDb2: db::TyperDB withContext: c::Context -> TypedExpr2 = [
  x = db dtc list toTypeInfoDefault
  db dtc char toTypeInfoDefault
  // todo optimize by adding core pkg to the TyperDB
  result = | this
  | CharExpr    => CharExprT :token typeInfo: db dtc char toTypeInfoDefault
  | IntExpr     => IntExprT :token typeInfo: db dtc int toTypeInfoDefault
  | FloatExpr   => FloatExprT :token typeInfo: db dtc float toTypeInfoDefault
  | DoubleExpr  => DoubleExprT :token typeInfo: db dtc double toTypeInfoDefault
  | StringExpr  => StringExprT :token typeInfo: db dtc str toTypeInfoDefault
  | BooleanExpr => BooleanExprT :token typeInfo: db dtc bool toTypeInfoDefault
  | NullExpr    => NullExprT :token typeInfo: db dtc nothing toTypeInfoDefault
  // Identifier can be type itself like Unit
  | Identifier   => [

    varType = c lookupForVar: this name
    | varType
    | null => [
      // this identifier can be name of the type and just a constructor call
      name first isUpperCase ifTrue: [
        q = db findByTypeName: name // TODO replace by findMaybe, and dont check for UpperCase

        IdentifierT :name :path :token typeInfo: q toTypeInfoDefault isNameOfTheType: true
      ] ifFalse: [
        contextString = c allKnownVars
        TO DO: "Cant find $this in the current context: \n$contextString"
      ]
    ]
    |=> IdentifierT :name :path :token typeInfo: varType toTypeInfoDefault isNameOfTheType: false

  ]
  | ExprInBrackets => [
    valueT = value toTypedExprFromDb2: db withContext: c
    ExprInBracketsT value: valueT :token typeInfo: valueT typeInfo
  ]
  | ListLiteral | SetLiteral => [
    this elements unTypedBody isEmpty ? [
      TO DO: "Can't infer type of the Collection collection without elements"
    ]
    typedBody = elements resolveBody2: db withContext: c
    Assert that: elements unTypedBody count equals: 0

    elems = typedBody v
    typesOfElems = elems map: [it typeInfo t]
    // take first and others
    // Compare all elements between each other
    f = typesOfElems first
    numberOfWrongElementType = f compareWithMany: (typesOfElems drop: 1)
    numberOfWrongElementType unpack: [
      wrongElement = elems at: it
      db addErrorMessage: (ErrorWrongArgType tok: this token msg: "Wront type of $wrongElement element, $f type expected")
    ]

    resultType =
      | this
      | ListLiteral => [
        newType = ListT t: f
        ListLiteralT :token elements: typedBody typeInfo: newType toTypeInfoDefault
      ]
      | SetLiteral => [
        typeInfo = SetT t: f, toTypeInfoDefault
        SetLiteralT :token elements: typedBody typeInfo: typeInfo
      ]
      |=> [TO DO]

      resultType
  ]
  | MapLiteral     => [
    this elements unTypedBody count % 2 != 0 ? [
      db addErrorMessage: (ErrorWrongArgCount tok: this token msg: "Number of arguments for Map should be even")
    ]
    this elements unTypedBody isEmpty ? [
      TO DO: "Can't infer type of the Map collection without elements"
    ]
    // resolve
    // compere each first and each second
    typedBody = elements resolveBody2: db withContext: c
    Assert that: elements unTypedBody count equals: 0

    elems = typedBody v
    typesOfElems = elems map: [it typeInfo t]

    // Compare every first with first, every second with second
    first = typesOfElems first debug
    second = typesOfElems at: 1, debug


    (typesOfElems drop: 2) debug forEachIndexed: [i, it ->
      i % 2 == 0 ? [
        i debug
        it debug compareWith: first, ifFalse: [
          db addErrorMessage: (ErrorWrongArgType
                                tok: this token
                                msg: "Wront type of $it element, $second value type expected")
        ]
      ] ! [
      i debug
        it debug compareWith: second, ifFalse: [
          db addErrorMessage: (ErrorWrongArgType
                                tok: this token
                                msg: "Wront type of $it element, $first key type expected")
        ]
      ]
    ]



    // if they all equal take first and second as k and v types


    MapLiteralT
      :token
      elements: typedBody
      typeInfo: (MapT k: first v: second) toTypeInfoDefault
  ]

  | UnaryMsg   => .resolveUnaryFromDb2: db withContext: c
  | BinaryMsg  => [
    this args isEmpty, ifTrue: [TO DO: "Compiler bug: binary without args"]
    ^ .replaceArgsWithTypedfromDb2: db withContext: c
  ]
  | KeywordMsg =>[
    this args isEmpty, ifTrue: [TO DO: "Compiler bug: keyword without args is like a single identifier"]
    ^ .resolveKeywordFromDb2: db withContext: c
  ]

  | VarDeclaration  => [
    // "var decl " + c toString, log
    typedExpr = this value toTypedExprFromDb2: db withContext: c

    // check that ast type is the same as declared
    this astType unpack: [
      // x::Int = "ars"
      nivaType = db findByTypeName: it name
      typedExpr typeInfo t compareWith: nivaType, ifFalse: [
        valName = name
        astTypeName = it name
        realTypeName = typedExpr typeInfo t name
        // TODO add it to error list
        TO DO: "Type declared for $valName is not equal for it's value type $astTypeName != $realTypeName"
      ]
    ]

    c defineVar: name withType: typedExpr typeInfo t

    VarDeclarationT
      :name
      value: typedExpr
      :astType
      :token
      typeInfo: db dtc unit toTypeInfoDefault

  ]
  | Assign => [
      method_receiver = c lookupForVar: "this"
      // if this has fienld of the same name
      kind = | method_receiver
              | null => AssignKind.TO_LOCAL_MUT
              |=> [
                  found_field = method_receiver findField: name
                  | found_field
                  | null => AssignKind.TO_LOCAL_MUT
                  |=>       AssignKind.TO_THIS_FIELD
              ]

      AssignT :name value: (value toTypedExprFromDb2: db withContext: c) :token typeInfo: db dtc unit toTypeInfoDefault :kind
  ]
  | DestructingAssign => DestructingAssignT :names value: (value toTypedExprFromDb2: db withContext: c) :token typeInfo: db dtc unit toTypeInfoDefault
  | ReturnStatement =>[
    valueT = value unpack: [expr -> expr toTypedExprFromDb2: db withContext: c] or: null
    returnType =
      | valueT
      | null => db dtc unit
      |=> valueT typeInfo t

    ReturnStatementT value: valueT
                     :token
                     typeInfo: returnType toTypeInfoDefault
  ]

  | CodeBlock => [
    c = Context fromParent: c

    typeTFields = args map: [
      {name astType} = it
      t = astType toNivaTypefromDB: db inPkg: null
      c defineVar: name withType: t
      TypeTField name: name typeT: t
    ]

    genericList = typeTFields
                    filter: [
                      {typeT} = it
                      | typeT
                      | UnresolvedGenericT => [true]
                      |=> [false]
                    ],
                    map: [it typeT]


    typedBody2 = body resolveBody2: db withContext: c
    returnType = typedBody2 t

    name = args joinWith: ":" transform: [it astType name], + ":"

    CodeBlockT :args :untypedArgs
      body: typedBody2
      :token
      typeInfo: (FuntionT
                  args: typeTFields
                  fields: typeTFields toMutableList
                  returnType: returnType
                  genericArgs: genericList toMutableList
                  name: name
                  pkgName: c currentPkg name) toTypeInfoDefault
  ]
  | Match     => [

    // TODO exhaustivness for unions and bool and enums and nullMatching
    elseb = elseBranch // local smart cast


    subjectT = subject toTypedExprFromDb2: db withContext: c
    elseBranchT =
      | elseb
      | null => [null]
      |=> [
        typedElseBody = elseb resolveBody2: db withContext: c
        typedElseBody
      ]

    // TODO infer common type between all branches
    mut matchType::NivaType = db dtc unit
    branchesT = branches map: [

      conditionsT = it conditions resolveBody2: db withContext: c
      bodyT = it body resolveBody2: db withContext: c

      matchType <- it body typedBody2 last typeInfo t

      MatchBranchT condition: (it condition toTypedExprFromDb2: db withContext: c)
                   conditions: conditionsT
                   body: bodyT
    ]


    newAst = MatchT subject: subjectT branches: branchesT elseBranch: elseBranchT token: token typeInfo: matchType toTypeInfoDefault
    ^ newAst
  ]
  | TypedExpr => TO DO: "Compiler bug: Recursive check, $this already type checked"


  ^ result
]





type CheckMethodArg nivaType: NivaType expr: Expr argName: String

// both for binary and keywords
/// checks that args from db and real args are the same
TyperDB checkRealArgs::List::CheckMethodArg withExpectedArgs::List::TypeTField = [
  Assert that: checkRealArgs count equals: withExpectedArgs count

  withExpectedArgs forEachIndexed: [ i, it ->
    {nivaType, expr, argName} = checkRealArgs at: i

    it typeT compareWith: nivaType, ifFalse: [
      expected = it typeT toString
      sended = nivaType toString
      exprStr = expr toString
      msg = "($sended != $expected) $expected expected, but $argName $exprStr is $sended"
      this addErrorMessage: (ErrorWrongArgType
                              tok: expr token
                              msg: msg)
    ]
  ]

]
