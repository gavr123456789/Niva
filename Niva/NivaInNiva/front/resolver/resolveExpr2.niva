/// used only for resolving body insied expressions, not for resolve body from message declarations
Body resolveBody2: db::TyperDB withContext: upperContext::Context -> TypedBody = [
  // StackTrace get log
  // Compiler getPlace log

  c = Context fromParent: upperContext

  // [] nothing to resolve
  unTypedBody isEmpty ifTrue: [
    ^ TypedBody v: {} t: db dtc unit
  ]


  Assert that: typedBody2 isEmpty equals: true

  // stackOfVisited::mut Set::MessageDecl = #()
  listOfTypedExpr2 = unTypedBody map: [ expr ->
    typed = expr toTypedExprFromDb2: db withContext: c
    typeOfExpr = typed typeInfo t
    // check that type is not Unknown
    | typeOfExpr | Unknown => [
      TO DO: "Unknown type of expr is not possible $expr"
    ] |=> []
    // if it is, then go and resolve the body, with remembering stack

    typed
  ]

  typedBody2 addAll: listOfTypedExpr2
  unTypedBody clear

  Assert that: typedBody2 isNotEmpty equals: true
  Assert that: unTypedBody isEmpty equals: true

  ^ TypedBody v: listOfTypedExpr2
              t: listOfTypedExpr2 last typeInfo t
]

// returns the number of wrong type element, if all good returns null
NivaType compareWithMany: types::List::NivaType -> Int? = [
  types forEachIndexed: [i, it ->
    x = this compareWith: it
    x ifFalse: [
      ^ i
    ]
  ]
  ^ null
]

Expr toTypedExprFromDb2: db::TyperDB withContext: c::Context -> TypedExpr2 = [

  // todo optimize by adding core pkg to the TyperDB
  result = | this
  | CharExpr    => CharExprT :token typeInfo: db dtc char toTypeInfoDefault
  | IntExpr     => IntExprT :token typeInfo: db dtc int toTypeInfoDefault
  | FloatExpr   => FloatExprT :token typeInfo: db dtc float toTypeInfoDefault
  | DoubleExpr  => DoubleExprT :token typeInfo: db dtc double toTypeInfoDefault
  | StringExpr  => StringExprT :token typeInfo: db dtc str toTypeInfoDefault
  | BooleanExpr => BooleanExprT :token typeInfo: db dtc bool toTypeInfoDefault
  | NullExpr    => NullExprT :token typeInfo: db dtc nothing toTypeInfoDefault
  // Identifier can be type itself like Unit
  | Identifier   => [

    varType = c lookupForVar: this name
    | varType
    | null => [
      // this identifier can be name of the type and just a constructor call
      name first isUpperCase ifTrue: [
        q = db findByTypeName: name // TODO replace by findMaybe, and dont check for UpperCase

        IdentifierT :name :path :token typeInfo: q toTypeInfoDefault isNameOfTheType: true
        // TypedExpr nivaType: (TypeOfTheType v: q) exprAst: this
      ] ifFalse: [
        contextString = c allKnownVars
        TO DO: "Cant find $this in the current context: \n$contextString"
      ]
    ]
    |=> IdentifierT :name :path :token typeInfo: varType toTypeInfoDefault isNameOfTheType: false

  ]
  | ExprInBrackets => [
    valueT = value toTypedExprFromDb2: db withContext: c
    ExprInBracketsT value: valueT :token typeInfo: valueT typeInfo
  ]
  | ListLiteral | SetLiteral => [
    this elements unTypedBody isEmpty ? [
      TO DO: "Can't infer type of the Collection collection without elements"
    ]
    typedBody = elements resolveBody2: db withContext: c
    Assert that: elements unTypedBody count equals: 0

    elems = typedBody v
    typesOfElems = elems map: [it typeInfo t]
    // take first and others
    // Compare all elements between each other
    f = typesOfElems first
    numberOfWrongElementType = f compareWithMany: (typesOfElems drop: 1)
    numberOfWrongElementType unpack: [
      wrongElement = elems at: it
      db addErrorMessage: (ErrorWrongArgType tok: this token msg: "Wront type of $wrongElement element, $f type expected")
    ]

    resultType =
      | this
      | ListLiteral => [
        newType = ListT t: f
        TO DO: "LISTSSSSS"
        // use addGenericInstantiationIfAbsent        
        TO DO: "Добавлять полученный тип в табличку ОРИГИНАЛ "
        ListLiteralT :token elements: typedBody typeInfo: newType toTypeInfoDefault
      ]
      | SetLiteral => [
        typeInfo = SetT t: f, toTypeInfoDefault
        SetLiteralT :token elements: typedBody typeInfo: typeInfo
      ]
      |=> [TO DO]

      resultType
  ]
  | MapLiteral     => [
    this elements unTypedBody count % 2 != 0 ? [
      db addErrorMessage: (ErrorWrongArgCount tok: this token msg: "Number of arguments for Map should be even")
    ]
    this elements unTypedBody isEmpty ? [
      TO DO: "Can't infer type of the Map collection without elements"
    ]
    // resolve
    // compere each first and each second
    typedBody = elements resolveBody2: db withContext: c
    Assert that: elements unTypedBody count equals: 0

    elems = typedBody v
    typesOfElems = elems map: [it typeInfo t]

    // Compare every first with first, every second with second
    first = typesOfElems first debug
    second = typesOfElems at: 1, debug


    (typesOfElems drop: 2) debug forEachIndexed: [i, it ->
      i % 2 == 0 ? [
        i debug
        it debug compareWith: first, ifFalse: [
          db addErrorMessage: (ErrorWrongArgType
                                tok: this token
                                msg: "Wront type of $it element, $second value type expected")
        ]
      ] ! [
      i debug
        it debug compareWith: second, ifFalse: [
          db addErrorMessage: (ErrorWrongArgType
                                tok: this token
                                msg: "Wront type of $it element, $first key type expected")
        ]
      ]
    ]



    // if they all equal take first and second as k and v types


    MapLiteralT
      :token
      elements: typedBody
      typeInfo: (MapT k: first v: second) toTypeInfoDefault
  ]

  | UnaryMsg   => .resolveUnaryFromDb2: db withContext: c
  | BinaryMsg  => [
    this args isEmpty, ifTrue: [TO DO: "Compiler bug: binary without args"]
    ^ .replaceArgsWithTypedfromDb2: db withContext: c
  ]
  | KeywordMsg =>[
    this args isEmpty, ifTrue: [TO DO: "Compiler bug: keyword without args is like a single identifier"]
    ^ .resolveKeywordFromDb2: db withContext: c
  ]

  | VarDeclaration  => [
    // "var decl " + c toString, log
    typedExpr = this value toTypedExprFromDb2: db withContext: c
    typedExpr debug
    // check that ast type is the same as declared
    this astType unpack: [
      // x::Int = "ars"
      nivaType = db findByTypeName: it name
      typedExpr typeInfo t compareWith: nivaType, ifFalse: [
        valName = name
        astTypeName = it name
        realTypeName = typedExpr typeInfo t name
        // TODO add it to error list
        TO DO: "Type declared for $valName is not equal for it's value type $astTypeName != $realTypeName"
      ]
    ]

    c defineVar: name withType: typedExpr typeInfo t

    VarDeclarationT
      :name
      value: typedExpr
      :astType
      :token
      typeInfo: db dtc unit toTypeInfoDefault

  ]
  | Assign => AssignT :name value: (value toTypedExprFromDb2: db withContext: c) :token typeInfo: db dtc unit toTypeInfoDefault
  | DestructingAssign => DestructingAssignT :names value: (value toTypedExprFromDb2: db withContext: c) :token typeInfo: db dtc unit toTypeInfoDefault
  | ReturnStatement =>[
    valueT = value unpack: [expr -> expr toTypedExprFromDb2: db withContext: c] or: null
    returnType =
      | valueT
      | null => db dtc unit
      |=> valueT typeInfo t

    ReturnStatementT value: valueT
                     :token
                     typeInfo: returnType toTypeInfoDefault
  ]

  | CodeBlock => [
    c = Context fromParent: c

    typeTFields = args map: [
      {name astType} = it
      t = astType toNivaTypefromDB: db inPkg: null
      c defineVar: name withType: t
      TypeTField name: name typeT: t
    ]

    genericList = typeTFields
                    filter: [
                      {typeT} = it
                      | typeT
                      | UnresolvedGenericT => [true]
                      |=> [false]
                    ],
                    map: [it typeT]


    typedBody2 = body resolveBody2: db withContext: c
    returnType = typedBody2 t

    name = args joinWith: ":" transform: [it astType name], + ":"

    CodeBlockT :args :untypedArgs
      body: typedBody2
      :token
      typeInfo: (FuntionT
                  args: typeTFields
                  returnType: returnType
                  genericArgs: genericList
                  name: name
                  pkgName: c currentPkg name) toTypeInfoDefault
  ]
  | Match     => [

    // TODO exhaustivness for unions and bool and enums and nullMatching
    elseb = elseBranch // local smart cast


    subjectT = subject toTypedExprFromDb2: db withContext: c
    elseBranchT =
      | elseb
      | null => [null]
      |=> [
        typedElseBody = elseb resolveBody2: db withContext: c
        typedElseBody
      ]

    // TODO infer common type between all branches
    mut matchType::NivaType = db dtc unit
    branchesT = branches map: [

      conditionsT = it conditions resolveBody2: db withContext: c
      bodyT = it body resolveBody2: db withContext: c

      matchType <- it body typedBody2 last typeInfo t

      MatchBranchT condition: (it condition toTypedExprFromDb2: db withContext: c)
                   conditions: conditionsT
                   body: bodyT
    ]


    newAst = MatchT subject: subjectT branches: branchesT elseBranch: elseBranchT token: token typeInfo: matchType toTypeInfoDefault
    ^ newAst
  ]
  | TypedExpr => TO DO: "Compiler bug: Recursive check, $this already type checked"


  ^ result
]





type CheckMethodArg nivaType: NivaType expr: Expr argName: String

// both for binary and keywords
TyperDB checkRealArgs::List::CheckMethodArg withExpectedArgs::List::TypeTField = [
  Assert that: checkRealArgs count equals: withExpectedArgs count

  withExpectedArgs forEachIndexed: [ i, it ->
    {nivaType, expr, argName} = checkRealArgs at: i

    it typeT compareWith: nivaType, ifFalse: [
      expected = it typeT toString
      sended = nivaType toString
      exprStr = expr toString
      msg = "($sended != $expected) $expected expected, but $argName $exprStr is $sended"
      this addErrorMessage: (ErrorWrongArgType
                              tok: expr token
                              msg: msg)
    ]
  ]

]


KeywordMsg resolveKeywordFromDb2: db::TyperDB withContext: c::Context  -> KeywordMsgT = [
  receiverTypedExpr = receiver toTypedExprFromDb2: db withContext: c
  receiverType = receiverTypedExpr typeInfo t debug
  argTypesAndExprs :: mut List::CheckMethodArg = {}!


  // так стоп, а как мы храним кейворды? вмеесте с :, потому что в этой реализации мы не разделяем сообщения по видам в базе
  kwMsgDB = db
    findMsgFromReceiver: receiverTypedExpr
    byName: .getNameFromArgs
    currentPkg: c currentPkg

  Assert that: kwMsgDB args count equals: args count

  
  
  // Всю эту часть потом нужно перенести в checkRealArgs: чтобы оно работало и для байнари
  
  
  letterToType::mut Map(String, NivaType) = #{}!

  typedArgs = args mapIndexed: [ i, kwArg ->
    {name expr} = kwArg
    typedExpr = expr toTypedExprFromDb2: db withContext: c
    realType = typedExpr typeInfo t
    argTypesAndExprs add: (CheckMethodArg
                            nivaType: typedExpr typeInfo t
                            expr: expr
                            argName: name name)

    argTypeFromDb = kwMsgDB args at: i, typeT
    | argTypeFromDb | UnresolvedGenericT => [
      // Check if we already resolved same letter to different type
      letterToType at: argTypeFromDb letter, unpack: [ alreadyResolvedTo::NivaType ->
        alreadyResolvedTo compareWith: typedExpr typeInfo t, ifFalse: [
          l = argTypeFromDb letter
          to = typedExpr typeInfo t
          TO DO: "Cant resolve $l to $to, it was already resolved to $alreadyResolvedTo"
        ]
      ]

      letterToType
        at: argTypeFromDb letter
        put: realType
    ] |=> [
      // вот, если это не женерик то сравниваем с тем шо в дб
      realType compareWith: argTypeFromDb, ifFalse: [
        db addErrorMessage: (ErrorWrongArgType
                              tok: expr token
                              msg: "Expected " + argTypeFromDb toString + " but got " + realType toString)
      ]
    ]


    // Да тут можно сразу и проверять тип чеуж там

    NameAndExprT name: name expr: typedExpr
  ]


  // К этому моменту мы проверили обычные типы, и получили таблицу женериков
  // теперь можно сгенерировать Msg с замененными женериками из оригинального, или получить если он уже был сгенерен
  // у инстанциированных типов, должны быть инстанциированные сообщения
  // мы будем затем находит интанциированные типы по id, и затем их сообщения

  // также нужно убрать отдельную таблицу конструкторов, наверное

  // try to find by id
  letterToType isNotEmpty ifTrue: [
    // 1) create new type with generic replaced based on receiverType, if it contains generics and this is a constructor
    // 1.1) if type does not contains generics but message contains, it seams okay, we can infer them from args
    // 1.2) if type does contains generics but message dont, then its a problem.
    // 2) create a new message, if it contains any generics, current letter to type not empty means it does
    receiverTypedExpr isIdentifierConstructor ifTrue: [
      // GENERIC DEFAULT CONSTRUCTOR - register instantiated variant
      | receiverType
      | TypeT => [
          newMethod = kwMsgDB replaceGenericsFromTable: letterToType db: db

          thisIsConstructor = kwMsgDB isConstructorForReceiver: receiverType
          thisIsConstructor ifTrue: [

            newReceiverType = newMethod receiverType
            | newReceiverType
            | TypeT => [
              x = db instantiatedCache at: receiverType
              x debug
              | x
              | null => TO DO: "oh no the map of instantiated methods is null"
              |=> [
                x at: newMethod name putIfAbsent: newMethod
                "Methods: Registrated generic instantiation of method: " + newMethod toString, log 
              ]
              recId = newReceiverType generateId // 100% not needed
              recFromDb = db typesById get: recId orPut: [ newReceiverType ] // same
              
              recFromDb debug 
              db instantiatedCache keys debug
            ]
            |=> [TO DO: "Compiler bug, should be TypeT"]
            // TO DO: "добавить в таблицу хешей получившийся метод, если его там еще нет"            

            
          ]

      ] |=> [
        TO DO: "generic constructor for usual receiver"

      ]
    ] ifFalse: [
      // GENERIC MESSAGE FOR OBJ - resolve generic method with true types
      TO DO: "GENERIC MESSAGE FOR OBJ"
    ]
  ] ifFalse: [
    // 1.2) check here
    | receiverType
    | TypeT => [
      isThereUnresolvedGenerics = receiverType genericArgs find: [
        | it
        | UnresolvedGenericT => [true]
        |=> [false]
      ]

      isThereUnresolvedGenerics unpack: [
        db addFatalErrorFromTok: receiver token 
           withMsg: "Receiver has generic param " + it toString + " but I can't infer it via message arguments" 
      ]

      Unit
    ] 
    |=> []

  ]

  TO DO: "ADD NEW MSG WITH INSTANTIATED PARAMS"


  // do not check if they are generics
  // no, probably just replace expected args here with real args, if they are generics

  // db checkRealArgs: argTypesAndExprs withExpectedArgs: kwMsgDB args // мы теперь сравниваем выше "realType compareWith: argTypeFromDb"
  newKeyword = KeywordMsgT
    args: typedArgs
    kind: kwMsgDB kind
    receiver: receiverTypedExpr
    token: token
    typeInfo: (TypeInfo
                  t: kwMsgDB returnType
                  isMut: kwMsgDB forMut)
    dbMsg: kwMsgDB

  ^ newKeyword
]

// rework - instead of replacing - make the receiver typed
BinaryMsg replaceArgsWithTypedfromDb2: db::TyperDB withContext: c::Context -> BinaryMsgT = [
  receiverTypedExpr = receiver toTypedExprFromDb2: db withContext: c

  typeOfReceiver = receiverTypedExpr typeInfo t
  mut lastType = typeOfReceiver
  mut lastReceiver = receiverTypedExpr
  mut lastDbMsg::NivaMethod? = null

  typedArgs = args map: [ binary ->
    // 1 + (2 inc)
    // find the message
    // resolce type of arg
    // compare that found message has arg with same type
    binaryName = binary name name
    dbMsg = db findMsgFromReceiver: lastReceiver  byName: binaryName currentPkg: c currentPkg
    lastDbMsg <- dbMsg

    (dbMsg args count != 1) ifTrue: [TO DO: "Compiler bug, binary $dbMsg args != 1 in db"]
    dbArg = dbMsg args first
    // resolve type of arg
    resolvedArg = binary expr toTypedExprFromDb2: db withContext: c


    (resolvedArg typeInfo t compareWith: dbArg typeT) ifFalse: [
      expected = dbMsg args first typeT
      butGot = resolvedArg typeInfo t
      currentBinary = lastType toString + " " + binaryName + " "
      TO DO: "In binary $currentBinary arg of type $expected expected, but got $butGot"
    ]

    // create typed expr with return type of dbMsg in db message
    typed = resolvedArg

    lastType <- dbMsg returnType // 2 + 2 ^(Int)+ 2
    lastReceiver <- resolvedArg // 2 + ^2 + 2
    NameAndExprT name: binary name expr: resolvedArg
  ]

  //
  newBinaryT = BinaryMsgT
    args: typedArgs
    receiver: receiverTypedExpr
    token: token
    typeInfo: lastType toTypeInfoDefault
    dbMsg: lastDbMsg unpackOrPANIC // this is +, its impossible to do 1 pkg.+ 2
  ^ newBinaryT
]


UnaryMsg resolveUnaryFromDb2:  db::TyperDB withContext: c::Context -> UnaryMsgT = [
  resolvedReceiver = receiver toTypedExprFromDb2: db withContext: c
  typeOfReceiver = resolvedReceiver typeInfo t
  dbMsg = db findMsgFromReceiver: resolvedReceiver byName: selector name currentPkg: c currentPkg

  typeInfo = TypeInfo t: dbMsg returnType isMut: dbMsg forMut
  newUnary2 = UnaryMsgT
    selector: selector
    kind: dbMsg kind
    receiver: resolvedReceiver
    token: token
    typeInfo: typeInfo
    dbMsg: dbMsg

  ^ newUnary2
]
