/// used only for resolving body insied expressions, not for resolve body from message declarations
Body resolveBody2(db): TyperDB withContext(upperContext): Context -> TypedBody = [
  // StackTrace get log
  // Compiler getPlace log

  c = Context fromParent: upperContext

  // [] nothing to resolve
  unTypedBody isEmpty ifTrue: [
    ^ TypedBody v: {} t: db dtc unit
  ]


  Assert that: typedBody2 isEmpty equals: true

  // stackOfVisited::mut Set::MessageDecl = #()
  listOfTypedExpr2 = unTypedBody map: [ expr ->
    typed = expr toTypedExprFromDb2: db withContext: c
    typeOfExpr = typed typeInfo t
    // check that type is not Unknown
    | typeOfExpr | Unknown => [
      TO DO: "Unknown type of expr is not possible $expr"
    ] |=> []
    // if it is, then go and resolve the body, with remembering stack

    typed
  ]

  typedBody2 addAll: listOfTypedExpr2
  unTypedBody clear

  Assert that: typedBody2 isNotEmpty equals: true
  Assert that: unTypedBody isEmpty equals: true

  ^ TypedBody v: listOfTypedExpr2
              t: listOfTypedExpr2 last typeInfo t
]

// returns the number of wrong type element, if all good returns null
NivaType compareWithMany(types): List::NivaType -> Int? = [
  types forEachIndexed: [i, it ->
    x = this compareWith: it
    x ifFalse: [
      ^ i
    ]
  ]
  ^ null
]

CodeBlock resolveWithExpectedType(db): TyperDB withContext(upperContext): Context expectedType: FuntionT -> CodeBlockT = [
  c = Context fromParent: upperContext

  expectedFields = expectedType fields

  typeTFields = args isNotEmpty
    ifTrue: [
      args map: [
        {name astType} = it
        t = astType toNivaTypefromDB: db inPkg: null
        c defineVar: name withType: t
        TypeTField name: name typeT: t
      ]
    ]
    ifFalse: [
      untypedArgs isNotEmpty
        ifTrue: [
          expectedFields count != untypedArgs count ifTrue: [
            db addErrorMessage: (ErrorWrongArgCount tok: token msg: "Wrong number of block args, expected " + expectedFields count toString)
          ]

          expectedFields count != untypedArgs count
            ifTrue: [{}]
            ifFalse: [
              untypedArgs mapIndexed: [i, ident ->
                expectedField = expectedFields at: i
                c defineVar: ident name withType: expectedField typeT
                TypeTField name: ident name typeT: expectedField typeT
              ]
            ]
        ]
        ifFalse: [
          expectedFields count == 1
            ifTrue: [
              expectedField = expectedFields first
              c defineVar: expectedField name withType: expectedField typeT
              { expectedField }
            ]
            ifFalse: [
              expectedFields isNotEmpty ifTrue: [
                db addErrorMessage: (ErrorWrongArgCount tok: token msg: "Block has no args, but expected " + expectedFields count toString)
              ]
              {}
            ]
        ]
    ]

  genericList = typeTFields
                  filter: [
                    {typeT} = it
                    | typeT
                    | UnresolvedGenericT => [true]
                    |=> [false]
                  ],
                  map: [it typeT]

  typedBody2 = body resolveBody2: db withContext: c
  returnType = typedBody2 t

  name = args isNotEmpty
    ifTrue: [args joinWith: ":" transform: [it astType name], + ":"]
    ifFalse: [
      untypedArgs isNotEmpty
        ifTrue: [untypedArgs joinWith: ":" transform: [it name], + ":"]
        ifFalse: [expectedType name]
    ]

  ^ CodeBlockT :args :untypedArgs
    body: typedBody2
    :token
    typeInfo: (FuntionT
                fields: typeTFields toMutableList
                returnType: returnType
                genericArgs: genericList toMutableList
                name: name
                pkgName: c currentPkg name) toTypeInfoDefault
]

Expr toTypedExprFromDb2(db): TyperDB withContext(c): Context -> TypedExpr2 = [
  x = db dtc list toTypeInfoDefault
  db dtc char toTypeInfoDefault
  // todo optimize by adding core pkg to the TyperDB
  result = | this
  | CharExpr    => CharExprT :token typeInfo: db dtc char toTypeInfoDefault
  | IntExpr     => IntExprT :token typeInfo: db dtc int toTypeInfoDefault
  | FloatExpr   => FloatExprT :token typeInfo: db dtc float toTypeInfoDefault
  | DoubleExpr  => DoubleExprT :token typeInfo: db dtc double toTypeInfoDefault
  | StringExpr  => StringExprT :token typeInfo: db dtc str toTypeInfoDefault
  | BooleanExpr => BooleanExprT :token typeInfo: db dtc bool toTypeInfoDefault
  | NullExpr    => NullExprT :token typeInfo: db dtc nothing toTypeInfoDefault
  // Identifier can be type itself like Unit
  | Identifier   => [

    varType = c lookupForVar: this name
    | varType
    | null => [
      // this identifier can be name of the type and just a constructor call
      name first isUpperCase ifTrue: [
        q = db findByTypeName: name // TODO replace by findMaybe, and dont check for UpperCase

        IdentifierT :name :path :token typeInfo: q toTypeInfoDefault isNameOfTheType: true
      ] ifFalse: [
        contextString = c allKnownVars
        TO DO: "Cant find $this in the current context: \n$contextString"
      ]
    ]
    |=> IdentifierT :name :path :token typeInfo: varType toTypeInfoDefault isNameOfTheType: false

  ]
  | ExprInBrackets => [
    valueT = value toTypedExprFromDb2: db withContext: c
    ExprInBracketsT value: valueT :token typeInfo: valueT typeInfo
  ]
  | ListLiteral | SetLiteral => [
    this elements unTypedBody isEmpty ? [
      TO DO: "Can't infer type of the Collection collection without elements"
    ]
    typedBody = elements resolveBody2: db withContext: c
    Assert that: elements unTypedBody count equals: 0

    elems = typedBody v
    typesOfElems = elems map: [it typeInfo t]
    // take first and others
    // Compare all elements between each other
    f = typesOfElems first
    numberOfWrongElementType = f compareWithMany: (typesOfElems drop: 1)
    numberOfWrongElementType unpack: [
      wrongElement = elems at: it
      db addErrorMessage: (ErrorWrongArgType tok: this token msg: "Wront type of $wrongElement element, $f type expected")
    ]

    astType =
      | this
      | ListLiteral => [
        newType = ListT t: f
        db addCollectionInstantiationIfAbsent: newType
        ListLiteralT :token elements: typedBody typeInfo: newType toTypeInfoDefault
      ]
      | SetLiteral => [
        newType = SetT t: f
        db addCollectionInstantiationIfAbsent: newType
        SetLiteralT :token elements: typedBody typeInfo: newType toTypeInfoDefault
      ]
      |=> [TO DO]

      astType
  ]
  | MapLiteral     => [
    this elements unTypedBody count % 2 != 0 ? [
      db addErrorMessage: (ErrorWrongArgCount tok: this token msg: "Number of arguments for Map should be even")
    ]
    this elements unTypedBody isEmpty ? [
      TO DO: "Can't infer type of the Map collection without elements"
    ]
    // resolve
    // compere each first and each second
    typedBody = elements resolveBody2: db withContext: c
    Assert that: elements unTypedBody count equals: 0

    elems = typedBody v
    typesOfElems = elems map: [it typeInfo t]

    // Compare every first with first, every second with second
    first = typesOfElems first
    second = typesOfElems at: 1


    (typesOfElems drop: 2), forEachIndexed: [i, it ->
      i % 2 == 0 ? [
        it compareWith: first, ifFalse: [
          db addErrorMessage: (ErrorWrongArgType
                                tok: this token
                                msg: "Wront type of $it element, $second value type expected")
        ]
      ] ! [
        it compareWith: second, ifFalse: [
          db addErrorMessage: (ErrorWrongArgType
                                tok: this token
                                msg: "Wront type of $it element, $first key type expected")
        ]
      ]
    ]



    // if they all equal take first and second as k and v types


    mapType = MapT k: first v: second
    db addCollectionInstantiationIfAbsent: mapType

    MapLiteralT
      :token
      elements: typedBody
      typeInfo: mapType toTypeInfoDefault
  ]

  | UnaryMsg   => .resolveUnaryFromDb2: db withContext: c
  | BinaryMsg  => [
    this args isEmpty, ifTrue: [TO DO: "Compiler bug: binary without args"]
    ^ .replaceArgsWithTypedfromDb2: db withContext: c
  ]
  | KeywordMsg =>[
    this args isEmpty, ifTrue: [TO DO: "Compiler bug: keyword without args is like a single identifier"]
    ^ .resolveKeywordFromDb2: db withContext: c
  ]

  | VarDeclaration  => [
    // "var decl " + c toString, log
    typedExpr = this value toTypedExprFromDb2: db withContext: c

    // check that ast type is the same as declared
    this astType unpack: [
      // x::Int = "ars"
      nivaType = db findByTypeName: it name
      typedExpr typeInfo t compareWith: nivaType, ifFalse: [
        valName = name
        astTypeName = it name
        realTypeName = typedExpr typeInfo t name
        // TODO add it to error list
        TO DO: "Type declared for $valName is not equal for it's value type $astTypeName != $realTypeName"
      ]
    ]

    c defineVar: name withType: typedExpr typeInfo t

    VarDeclarationT
      :name
      value: typedExpr
      :astType
      :token
      typeInfo: db dtc unit toTypeInfoDefault

  ]
  | Assign => [
      method_receiver = c lookupForVar: "this"
      // if this has fienld of the same name
      kind = | method_receiver
              | null => AssignKind.TO_LOCAL_MUT
              |=> [
                  found_field = method_receiver findField: name
                  | found_field
                  | null => AssignKind.TO_LOCAL_MUT
                  |=>       AssignKind.TO_THIS_FIELD
              ]

      AssignT :name value: (value toTypedExprFromDb2: db withContext: c) :token typeInfo: db dtc unit toTypeInfoDefault :kind
  ]
  | DestructingAssign => DestructingAssignT :names value: (value toTypedExprFromDb2: db withContext: c) :token typeInfo: db dtc unit toTypeInfoDefault
  | ReturnStatement =>[
    valueT = value unpack: [expr -> expr toTypedExprFromDb2: db withContext: c] or: null
    returnType =
      | valueT
      | null => db dtc unit
      |=> valueT typeInfo t

    ReturnStatementT value: valueT
                     :token
                     typeInfo: returnType toTypeInfoDefault
  ]

  | CodeBlock => [
    c = Context fromParent: c

    typeTFields = args isNotEmpty
      ifTrue: [
        args map: [
          {name astType} = it
          t = astType toNivaTypefromDB: db inPkg: null
          c defineVar: name withType: t
          TypeTField name: name typeT: t
        ]
      ]
      ifFalse: [
        untypedArgs isNotEmpty
          ifTrue: [
            untypedArgs map: [ident ->
              unresolvedT = UnresolvedGenericT name: ident name
              c defineVar: ident name withType: unresolvedT
              TypeTField name: ident name typeT: unresolvedT
            ]
          ]
          ifFalse: [{}]
      ]

    genericList = typeTFields
                    filter: [
                      {typeT} = it
                      | typeT
                      | UnresolvedGenericT => [true]
                      |=> [false]
                    ],
                    map: [it typeT]


    typedBody2 = body resolveBody2: db withContext: c
    returnType = typedBody2 t

    name = args isNotEmpty
      ifTrue: [args joinWith: ":" transform: [it astType name], + ":"]
      ifFalse: [
        untypedArgs isNotEmpty
          ifTrue: [untypedArgs joinWith: ":" transform: [it name], + ":"]
          ifFalse: [""]
      ]

    CodeBlockT :args :untypedArgs
      body: typedBody2
      :token
      typeInfo: (FuntionT
                  fields: typeTFields toMutableList
                  returnType: returnType
                  genericArgs: genericList toMutableList
                  name: name
                  pkgName: c currentPkg name) toTypeInfoDefault
  ]
  | Match     => [

    // TODO exhaustivness for unions and bool and enums and nullMatching
    elseb = elseBranch // local smart cast


    subjectT = subject toTypedExprFromDb2: db withContext: c
    elseBranchT =
      | elseb
      | null => [null]
      |=> [
        typedElseBody = elseb resolveBody2: db withContext: c
        typedElseBody
      ]

    // TODO infer common type between all branches
    mut matchType::NivaType = db dtc unit
    branchesT = branches map: [

      conditionsT = it conditions resolveBody2: db withContext: c
      bodyT = it body resolveBody2: db withContext: c

      matchType <- it body typedBody2 last typeInfo t

      MatchBranchT condition: (it condition toTypedExprFromDb2: db withContext: c)
                   conditions: conditionsT
                   body: bodyT
    ]


    newAst = MatchT subject: subjectT branches: branchesT elseBranch: elseBranchT token: token typeInfo: matchType toTypeInfoDefault
    ^ newAst
  ]
  | TypedExpr => TO DO: "Compiler bug: Recursive check, $this already type checked"


  ^ result
]





type CheckMethodArg nivaType: NivaType expr: Expr argName: String

// both for binary and keywords
/// checks that args from db and real args are the same
TyperDB checkRealArgs(checkRealArgs): List::CheckMethodArg withExpectedArgs(withExpectedArgs): List::TypeTField = [
  Assert that: checkRealArgs count equals: withExpectedArgs count

  withExpectedArgs forEachIndexed: [ i, it ->
    {nivaType, expr, argName} = checkRealArgs at: i

    it typeT compareWith: nivaType, ifFalse: [
      expected = it typeT toString
      sended = nivaType toString
      exprStr = expr toString
      msg = "($sended != $expected) $expected expected, but $argName $exprStr is $sended"
      this addErrorMessage: (ErrorWrongArgType
                              tok: expr token
                              msg: msg)
    ]
  ]

]
