// why is these good? - some errors can contain second place in code to show!
union ResolveErrors tok: Token msg: String =
| ErrorNoSuchType
| ErrorWrongArgType
| ErrorWrongArgCount
| LazyError



union AstVisitor =
| PrintingVisitor //sb: StringBuilder
| TypeDeclVisitor db: TyperDB
| MsgDeclVisitor
| GoBackendVisitor

AstVisitor run(statements): List::Statement = [
  statements forEach: [
    this visit: it
  ]
]

PrintingVisitor visit(st): Statement = [
  st echo
  "--------------" echo
]

/// returns pkg to message decl
/// entryPointStatements just all statements from the main.niva
/// not only expr
TypeDeclVisitor
  visitAllTypesThenTypesAndMethods(fileToStatements): Map(String, List::Statement)
  entryPointStatements::List::Statement
  -> List(Tuple(String, MessageDecl)) = [

  pkgTotypeDecls2::mut List(Tuple(String, TypeDecl)) = {}!
  noFieldsTypes::mut Map(String, TypeT) = #{}!
  msgDecls2::mut List(Tuple(String, MessageDecl)) = {}!

  // expressions of the main file
  entryPointExpressions:: mut List::Expr = {}!
  entryPointStatements forEach: [
    | it
    | Expr => entryPointExpressions add: it
    |=> []
  ]

  processDeclarations = [file::String, statements::List::Statement ->
    pkgName = file

    db addNewPkgIfNotExists: pkgName

    // TODO unions, enums, aliases
    // save all types (without fields), and msg decls
    statements forEach: [
      | it
      | TypeDecl => [
        noFieldsType = TypeT noFieldsWithName: it name pkgName: pkgName
        noFieldsTypes at: it name put: noFieldsType
        pkgTotypeDecls2 add: (Tuple x: pkgName y: it)
      ]
      | MessageDecl => [
        msgDecls2 add: (Tuple x: pkgName y: it)
        Unit
      ]
      // msgDecls at: pkgName put: it debug
      | UnionDecl => TO DO: "UnionDecl"
      | EnumDecl => TO DO: "EnumDecl"
      |=> []
    ]
  ]

  // first iteration, fill the lists of statements, create pkgs
  fileToStatements forEach: [file, statements ->
    processDeclarations file: file statements: statements
  ]

  fillTypesAndMessages = [
    pkgTotypeDecls2 forEach: [ tuple ->
      pkgName = tuple x
      typeDecl = tuple y

      readyToAddToDBType = .fillFields: typeDecl knownTypes: noFieldsTypes
      readyToAddToDBType unpack: [ resolvedType ->

        db
          addNewType: resolvedType
          inPkg: pkgName

        // add fields

        db
          addNewConstructor: resolvedType generateDefaultConstructor
          forType: resolvedType


        // это снова происходит внутри  .fillFields
        // нет, это нельзя делать в фил филдс потому что addNewMethod использует уже добавленый тип, а там все на стабах недобавленных
        addFields = [
          resolvedType fields forEach: [ field ->

            getter = NivaMethod
              name: field name
              receiverType: resolvedType
              args: {}
              returnType: field typeT
              forMut: false // false because its getter
              possibleErrors: {}
              kind: MessageSendKind.Getter
              decl: null
              protocolName: "getters"
              pkgName: "core" // this is getter

            db addNewMethod: getter forType: resolvedType inProtocol: "getters"

          ]
        ] do

        "Types: added type " + resolvedType name + " in pkg " + pkgName, log

      ]
      readyToAddToDBType == null ifTrue: [
        name = typeDecl name
        TO DO: "cant fill fields for $name"
      ]
    ]


  // msg decls resolving
  // here we should have all the types resolved
  // msgDecls2 addFirst: (Tuple x: "main" y: entry)

// first resolve all the declarations
// then resolve main "body"
// then resolve all others method's bodies
    msgDecls2 forEach: [ tuple ->
      pkg = tuple x
      msg = tuple y

      // get real type for receiver

      receiverAst = msg receiver
      receiverType = receiverAst toNivaTypefromDB: db inPkg: null


      | receiverType | TypeT => []
      |=> []

      receiverNeedsGenerics = | receiverType
      | TypeT => receiverType genericArgs isNotEmpty
      |=> false

      receiverDeclaresGenerics = | receiverAst
      | AstType => receiverAst genericParams isNotEmpty
      |=> false

      receiverNeedsGenerics ifTrue: [
        receiverDeclaresGenerics ifFalse: [
          db addErrorFromTok: receiverAst tok
            withMsg: "Receiver type " + receiverType name + " requires generic params"
        ]
      ]

      // get real type for each arg
      argsT = msg args map: [ arg ->
        argType = arg astType toNivaTypefromDB: db inPkg: null // we cant know the concrete pkg here
        TypeTField name: arg name typeT: argType
      ]


      astOfReceiver = msg receiver
      isMutable = | astOfReceiver
      | AstType => astOfReceiver isMut
      | AstLambdaType => false


      method = NivaMethod
        name: msg name
        receiverType: receiverType
        args: argsT
        returnType: (msg getReturnTypeFromDb: db) // if generic need to resolve
        forMut: isMutable
        possibleErrors: {}
        kind: MessageSendKind.Call
        decl: msg
        protocolName: "common"
        pkgName: pkg

      db addNewMethod: method forType: receiverType inProtocol: null
      "Methods: added method " + method name + " in pkg: " + pkg, log
    ]

// resolve main
    mainBody::mut Body = (Body unTypedBody: entryPointExpressions typedBody2: {}!)
    // create entry point pkg
    entryPointPkg = db addNewPkgIfNotExists: "entryPoint"
    typedMain = mainBody
      resolveBody2: db
      withContext: (Context rootWithPkg: entryPointPkg)

    // mainBody typedBody2 addAll:


    fakeUnitAstType = AstType2 unitType


    fakeMsgDecl = MessageDecl receiver: fakeUnitAstType
      name: "entryPoint" args: {}
      returnType: fakeUnitAstType body: mainBody
      isSingleExpr: false isConstructor: false
      token: (mainBody unTypedBody isNotEmpty ifTrue: [mainBody unTypedBody first token]  ifFalse: [Token fake])




    msgDecls2 add: (Tuple x: "entryPoint" y: fakeMsgDecl)
  ] do
  ^ msgDecls2
]

/// if no return type and has body then its Unit
/// if no return type and isSingleExpr then its unknown
MessageDecl getReturnTypeFromDb(db): TyperDB -> NivaType = [

  rt = returnType
 ^| rt
  | null => [
    | isSingleExpr
    | true => Unknown new
    | false => db dtc unit
  ]
  |=> db findByTypeName: rt name inPkg: null
]

/// returns a type with fields filled with real types, ready to add to db
/// returns null if such type was not found in knownTypeNames or db
/// and adds that as error to listOfErrors
TypeDeclVisitor fillFields(st): TypeDecl knownTypes::mut Map(String, TypeT) -> TypeT? = [
  name = st name
  typeStub = knownTypes at: name

  | typeStub
  | null => [
    db listOfErrors add: (ErrorNoSuchType tok: st token msg: "type $name not found")

    ^ null
  ]
  |=> [


    st fields forEach: [
      fieldName = it astType name
      knownNames = knownTypes keys
      // search in known types, if not found search in db, db always has core types,
      // known types contains every type from AST decls
      maybeFieldType = knownTypes at: fieldName
      fieldType = | maybeFieldType
      | null => db findByTypeName: fieldName inPkg: null
      |=> maybeFieldType

      field = TypeTField name: it name typeT: fieldType
      typeStub fields add: field

      // getter = NivaMethod
      //   name: it name
      //   receiverType: typeStub
      //   args: {}
      //   returnType: fieldType
      //   forMut: false // false because its getter
      //   possibleErrors: {}
      //   kind: MessageSendKind.Getter
      //   decl: null
      //   protocolName: "getters"
      //   pkgName: "core" // this is getter

      // db addNewMethod: getter forType: typeStub inProtocol: "getters"
    ]


    // пока шо с стейтментом ниче не делаем, нагенерим мономорфных типов потом когда будет сас

    typeStub genericArgs addAll: typeStub collectGenerics
    ^ typeStub
  ]
]

MsgDeclVisitor processBodyes(pkg2Msg): List(Tuple(String, MessageDecl)) db::TyperDB = [
  pkg2Msg forEach: [tuple ->
    pkgStr = tuple x
    pkg = db packages at: pkgStr, unpackOrPANIC

    msgDecl = tuple y

    receiverType = msgDecl receiver toNivaTypefromDB: db inPkg: null
    extraTypes::mut Map(String, NivaType) = #{}!
    | receiverType
    | TypeT => [
       receiverType genericArgs forEach: [
         extraTypes at: it name put: it
       ]
    ]
    |=> []

    msgDecl resolveBodyWithDb: db :pkg :extraTypes
  ]
]

// every message with its context attached
// context is a tree like structure with parents
// every context contains all the symbols inside, resolved
type MessagesWithContext
  data: Map(MessageDecl, Context)

/// fills typedBody inside body
MessageDecl resolveBodyWithDb(db): TyperDB pkg: NivaPkg extraTypes: mut Map(String, NivaType) = [
  //"resolving body of " + this name + " from pkg: " + pkg name, log

  // put extra types to db
  db localGenericScope putAll: extraTypes

// add receiver as "this" and args to the context
  createContextWithThisAndArgs = [
    c = Context rootWithPkg: pkg
    receiver = db findByTypeName: receiver name inPkg: null
    receiver name == "Nothing" ifTrue: [
      TO DO: "You cant declare methods for Nothing type"
    ]

    c defineVar: "this" withType: receiver


    args forEach: [
      argType = db findByTypeName: it astType name inPkg: null
      c defineVar: it name withType: argType
    ]

    c
  ]
// resolve body
  c = createContextWithThisAndArgs do

  body resolveBody2: db withContext: c

  // clean up local scope
  extraTypes keys forEach: [
    db localGenericScope remove: it
  ]
]




AstVisitor visit(st): Statement = [
  | this
  | PrintingVisitor => this visit: st
  | TypeDeclVisitor => [
    | st
    | TypeDecl => this visit: st
    |=>[]
    Unit
  ]
  | MsgDeclVisitor => [
    TO DO
  ]
  | GoBackendVisitor => [
    this visit: st
  ]
]
