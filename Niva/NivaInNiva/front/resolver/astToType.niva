

AstType2 toNivaTypefromDB: db::TyperDB inPkg::String? -> NivaType = [




  x = | this
  | AstType => [
    name isGeneric ifTrue: [
      ^ UnresolvedGenericT name: name
    ]

    typeT = db findByTypeName: name :inPkg
    result = genericParams isNotEmpty ifTrue: [
      // transform each generic astType to real type
      // create table of them
      // replace T with real types from the table
      | typeT
      | TypeT => [
        Assert that: typeT genericArgs count
             equals: genericParams count



        idToType:: mut Map(String, NivaType) = #{}!
        mut hasConcreteGeneric = false

        typeT genericArgs forEachIndexed: [ i, it ->
          sas = genericParams at: i, toNivaTypefromDB: db inPkg: inPkg
          | sas
          | UnresolvedGenericT => []
          |=> [hasConcreteGeneric <- true]
          idToType at: it name put: sas
        ]

        idToType debug
        hasConcreteGeneric
          ifTrue: [db addGenericInstantiationIfAbsent: typeT letterToType: idToType]
          ifFalse: [typeT]
      ]
      | ListT => [
        genericParams count != 1 ifTrue: [
          db addErrorFromTok: tok withMsg: "List expects 1 generic param, got " + genericParams count toString
          ^ typeT
        ]
        inner = genericParams first, toNivaTypefromDB: db inPkg: inPkg
        ListT t: inner
      ]
      | SetT => [
        genericParams count != 1 ifTrue: [
          db addErrorFromTok: tok withMsg: "Set expects 1 generic param, got " + genericParams count toString
          ^ typeT
        ]
        inner = genericParams first, toNivaTypefromDB: db inPkg: inPkg
        SetT t: inner
      ]
      | MapT => [
        genericParams count != 2 ifTrue: [
          db addErrorFromTok: tok withMsg: "Map expects 2 generic params, got " + genericParams count toString
          ^ typeT
        ]
        keyType = genericParams at: 0, toNivaTypefromDB: db inPkg: inPkg
        valType = genericParams at: 1, toNivaTypefromDB: db inPkg: inPkg
        MapT k: keyType v: valType
      ]
      |=> [TO DO: "only TypeT/ListT/SetT/MapT can have generics"]
    ] ifFalse: [
      typeT
    ]

    result
  ]
  | AstLambdaType => [TO DO]

  ^ x
]
