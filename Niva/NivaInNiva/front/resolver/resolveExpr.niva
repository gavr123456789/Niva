Expr toTypedExprFromDb: db::TyperDB withContext: c::Context -> TypedExpr = [

  
  // todo optimize by adding core pkg to the TyperDB
 ^| this
  | CharExpr    => TypedExpr nivaType: (db dtc char) exprAst: this
  | IntExpr     => TypedExpr nivaType: (db dtc int) exprAst: this
  | FloatExpr   => TypedExpr nivaType: (db dtc float) exprAst: this
  | DoubleExpr  => TypedExpr nivaType: (db dtc double) exprAst: this
  | StringExpr  => TypedExpr nivaType: (db dtc str) exprAst: this
  | BooleanExpr => TypedExpr nivaType: (db dtc bool) exprAst: this
  | NullExpr    => TypedExpr nivaType: (db dtc nothing) exprAst: this
  // Identifier can be type itself like Unit
  | Identifier     => [

    varType = c lookupForVar: this name
    | varType
    | null => [
      // this identifier can be name of the type and just a constructor call  
      name first isUpperCase ifTrue: [
        q = db findByTypeName: name
        TypedExpr nivaType: (TypeOfTheType v: q) exprAst: this
      ] ifFalse: [
        contextString = c allKnownVars        
        TO DO: "Cant find $this in the current context: \n$contextString"
      ]
    ]
    |=> TypedExpr nivaType: varType exprAst: this
    
  ]
  | ExprInBrackets => value toTypedExprFromDb: db withContext: c
  | ListLiteral    => [
    elements resolveBody: db withContext: c
    // Compare all elements between each other
    TO DO: "ListLiteral to TypedExpr"]
  | SetLiteral     => [
    elements resolveBody: db withContext: c
    TO DO: "SetLiteral to TypedExpr"]
  | MapLiteral     => TO DO: "MapLiteral to TypedExpr" 

  | UnaryMsg   => [
    // replacing every expr inside typeAndExpr with typedExpr to be able to tell the types of each arg
    // this args isEmpty, ifTrue: [TO DO: "Compiler bug: unary without args is like a single identifier"]
      typedExpr = .resolveFromDb: db withContext: c
      ^ typedExpr
    ]
  | BinaryMsg  => [
    this args isEmpty, ifTrue: [TO DO: "Compiler bug: binary without args"]
    
    {x y} = .replaceArgsWithTypedfromDb: db withContext: c
    ^TypedExpr 
      exprAst: x 
      nivaType: y 
      isMutable: false 
      token: token
    ]
  | KeywordMsg =>[ 
    this args isEmpty, ifTrue: [TO DO: "Compiler bug: keyword without args is like a single identifier"]
    typedExpr = .resolveKeywordFromDb: db withContext: c

    ^typedExpr 
  ]

  | VarDeclaration  => [
    // "var decl " + c toString, log
    typedExpr = this value toTypedExprFromDb: db withContext: c
    // check that ast type is the same as declared
    this astType unpack: [
      // x::Int = "ars"
      nivaType = db findByTypeName: it name
      typedExpr nivaType compareWith: nivaType, ifFalse: [
        valName = name
        astTypeName = it name
        realTypeName = typedExpr nivaType name
        // TODO add it to error list
        TO DO: "Type declared for $valName is not equal for it's value type $astTypeName != $realTypeName"
      ]
    ]

    c defineVar: name withType: typedExpr nivaType

    TypedExpr 
      nivaType: db dtc unit
      exprAst: typedExpr 
      isMutable: typedExpr isMutable
  ]
  | Assign => TO DO
  | DestructingAssign => TO DO
  | ReturnStatement => TO DO: "ReturnStatement to TypedExpr"

  | CodeBlock => [

    body unTypedBody isEmpty ifTrue: [
      TypedExpr nivaType: (db dtc unit) exprAst: this
    ] ifFalse: [
      "CodeBlock"
      body resolveBody: db withContext: c
      TypedExpr 
        nivaType: body typedBody last nivaType 
        exprAst: this 
    ]
  ]
  | Match     => [

    // TODO exhaustivness for unions and bool and enums
    elseb = elseBranch // local smart cast


    subjectT = subject toTypedExprFromDb: db withContext: c
    elseBranchT = 
      | elseb
      | null => [null]
      |=> [
        elseb resolveBody: db withContext: c
        elseb
      ] 
    
    // TODO infer common type between all branches
    mut matchType::NivaType = db dtc unit
    branchesT = branches map: [

      it conditions resolveBody: db withContext: c
      it body       resolveBody: db withContext: c
      
      matchType <- it body typedBody last nivaType

      MatchBranch 
        condition: (it condition toTypedExprFromDb: db withContext: c)
        conditions: it conditions 
        body: it body
    ]
    // branchesT log
    

    
    newAst = Match subject: subjectT branches: branchesT elseBranch: elseBranchT token: token

    r = TypedExpr exprAst: newAst nivaType: matchType isMutable: false token: token
    ^ r 
  ]
  | TypedExpr => TO DO: "Compiler bug: Recursive check, $this already type checked"


  // result = TypedExpr nivaType: TO DO isMutable: TO DO
  // ^ result
]


type Tuple x: T y: G 

KeywordMsg getNameFromArgs -> String = [
  ^ args joinWith: ":" transform: [
    it name name
  ], + ":"
]


type CheckMethodArg nivaType: NivaType expr: Expr argName: String
// both for binary and keywords
TyperDB checkRealArgs::List::CheckMethodArg withExpectedArgs::List::TypeTField = [
  Assert that: checkRealArgs count equals: withExpectedArgs count

  withExpectedArgs forEachIndexed: [ i, it ->
    {nivaType, expr, argName} = checkRealArgs at: i 
    

    it typeT compareWith: nivaType, ifFalse: [
      expected = it typeT toString
      sended = nivaType toString
      exprStr = expr toString
      
      
      this addErrorMessage: (ErrorWrongArgType 
                              tok: expr token 
                              msg: "($sended != $expected) $expected expected, but $argName $exprStr is $sended")
    ]
  ]

]

KeywordMsg resolveKeywordFromDb: db::TyperDB withContext: c::Context -> TypedExpr = [
  receiverTypedExpr = receiver toTypedExprFromDb: db withContext: c
  receiverType = receiverTypedExpr nivaType
  argTypesAndExprs :: mut List::CheckMethodArg = {}!


  // так стоп, а как мы храним кейворды? вмеесте с :, потому что в этой реализации мы не разделяем сообщения по видам в базе
  foundMsg = db 
    findMsgFromReceiver: receiverType 
    byName: .getNameFromArgs
  
  Assert that: foundMsg args count equals: args count

  letterToType::mut Map(String, NivaType) = #{}!

  typedArgs = args mapIndexed: [ i, kwArg -> 
    {name expr} = kwArg
    typedExpr = expr toTypedExprFromDb: db withContext: c
    argTypesAndExprs add: (CheckMethodArg 
                            nivaType: typedExpr nivaType 
                            expr: expr 
                            argName: name name)
    
    argTypeFromDb = foundMsg args at: i, typeT
    | argTypeFromDb | UnresolvedGenericT => [
      // Check if we already resolved same letter to different type
      letterToType at: argTypeFromDb letter, unpack: [ alreadyResolvedTo::NivaType ->
        alreadyResolvedTo compareWith: typedExpr nivaType, ifFalse: [
          l = argTypeFromDb letter
          to = typedExpr nivaType
          TO DO: "Cant resolve $l to $to, it was already resolved to $alreadyResolvedTo"
        ]
      ]
      
      letterToType 
        at: argTypeFromDb letter 
        put: typedExpr nivaType
    ] |=> []

    NameAndExpr name: name expr: typedExpr
  ]
  
  // если это конструктор то скорее всего генерим 
  
  // try to find by id
  letterToType isNotEmpty && true ifTrue: [
    // GENERIC CONSTRUCTOR - register instantiated variant
    | receiverType
    | TypeOfTheType => [
      realT = receiverType v 
      | realT
      | TypeT => [
        thisIsConstructor = foundMsg isConstructorForReceiver: realT
        thisIsConstructor ifTrue: [
          // typeId = receiverType generateId

          db addGenericInstantiationIfAbsent: realT
             letterToType: letterToType 
        ]


        // TO DO: "SAS"
      ] |=> []

    ]
    |=> [
      // GENERIC MESSAGE FOR OBJ - resolve generic method with true types
      TO DO: "GENERIC MESSAGE FOR OBJ"

    ]
  ]

  
  // do not check if they are generics
  db checkRealArgs: argTypesAndExprs withExpectedArgs: foundMsg args


  newKeyword = KeywordMsg 
    args: typedArgs 
    receiver: receiverTypedExpr 
    token: token
    kind: foundMsg kind
  // TO DO
  ^TypedExpr 
    exprAst: newKeyword
    nivaType: foundMsg returnType
    isMutable: false 
    token: token
] 


BinaryMsg replaceArgsWithTypedfromDb: db::TyperDB withContext: c::Context -> Tuple(BinaryMsg, NivaType) = [ 
  receiverTypedExpr = receiver toTypedExprFromDb: db withContext: c

  typeOfReceiver = receiverTypedExpr nivaType
  mut lastType = typeOfReceiver

  typedArgs = args map: [ binary ->
    // 1 + (2 inc)
    // find the message
    // resolce type of arg
    // compare that found message has arg with same type
    binaryName = binary name name
    dbMsg = db findMsgFromReceiver: lastType  byName: binaryName
    (dbMsg args count != 1) ifTrue: [TO DO: "Compiler bug, binary $dbMsg args != 1 in db"]
    dbArg = dbMsg args first
    // resolve type of arg
    resolvedArg = binary expr toTypedExprFromDb: db withContext: c


    (resolvedArg nivaType compareWith: dbArg typeT) ifFalse: [
      expected = dbMsg args first typeT
      butGot = resolvedArg nivaType
      currentBinary = lastType toString + " " + binaryName + " " 
      TO DO: "In binary $currentBinary arg of type $expected expected, but got $butGot"
    ]

    // create typed expr with return type of dbMsg in db message
    typed = TypedExpr 
      exprAst: binary name 
      nivaType: dbMsg returnType 
      isMutable: false 
      token: binary name token

    lastType <- dbMsg returnType
    NameAndExpr name: binary name expr: typed
  ]

  newBinary = BinaryMsg args: typedArgs receiver: receiverTypedExpr token: token
  ^ Tuple x: newBinary y: lastType 
] 


UnaryMsg resolveFromDb:  db::TyperDB withContext: c::Context -> TypedExpr = [
  resolvedReceiver = receiver toTypedExprFromDb: db withContext: c
  typeOfReceiver = resolvedReceiver nivaType
  dbMsg = db findMsgFromReceiver: typeOfReceiver  byName: selector name

  newUnary = UnaryMsg 
    receiver: resolvedReceiver 
    selector: selector
    token: token
    kind: dbMsg kind

  typed = TypedExpr 
    exprAst: newUnary
    nivaType: dbMsg returnType log 
    isMutable: dbMsg forMut 
    token: selector token


  ^ typed
]