Expr toTypedExprFromDb: db::TyperDB withContext: c::Context -> TypedExpr = [
  

 ^| this
  | CharExpr    => TypedExpr nivaType: (db findByTypeName: "Char") exprAst: this
  | IntExpr     => TypedExpr nivaType: (db findByTypeName: "Int") exprAst: this
  | FloatExpr   => TypedExpr nivaType: (db findByTypeName: "Float") exprAst: this
  | DoubleExpr  => TypedExpr nivaType: (db findByTypeName: "Double") exprAst: this
  | StringExpr  => TypedExpr nivaType: (db findByTypeName: "String") exprAst: this
  | BooleanExpr => TypedExpr nivaType: (db findByTypeName: "Boolean") exprAst: this
  | NullExpr    => TypedExpr nivaType: (db findByTypeName: "Null") exprAst: this
  // Identifier can be type itself like Unit
  | Identifier     => [
    varType = c lookupForVar: this name
    | varType
    | null => TO DO: "Cant find $this in the current context"
    |=> [
      varType 
      TypedExpr nivaType: varType exprAst: this
    ]
  ]
  | ExprInBrackets => TO DO: "ExprInBrackets to TypedExpr"
  | ListLiteral    => TO DO: "ListLiteral to TypedExpr"
  | SetLiteral     => TO DO: "SetLiteral to TypedExpr"
  | MapLiteral     => TO DO: "MapLiteral to TypedExpr" 

  | UnaryMsg   => [
    // replacing every expr inside typeAndExpr with typedExpr to be able to tell the types of each arg
    this args isEmpty, ifTrue: [TO DO: "Compiler bug: unary without args is like a single identifier"]
    tupleOfUnaryAndType = .replaceArgsWithTypedfromDb: db withContext: c
    ^TypedExpr 
      exprAst: tupleOfUnaryAndType x 
      nivaType: tupleOfUnaryAndType y 
      isMutable: false 
      token: token

    ]
  | BinaryMsg  => TO DO: "BinaryMsg to TypedExpr"
  | KeywordMsg =>[ 
    this args isEmpty, ifTrue: [TO DO: "Compiler bug: keyword without args is like a single identifier"]
    kek = .resolveKeywordFromDb: db withContext: c

    
    TO DO: "KeywordMsg to TypedExpr"]

  | VarDeclaration  => [

    typedExpr = this value toTypedExprFromDb: db withContext: c
    // check that ast type is the same as declared
    this astType unpack: [
      // x::Int = "ars"
      nivaType = db findByTypeName: it name
      typedExpr nivaType compareWith: nivaType, ifFalse: [
        valName = name
        astTypeName = it name
        realTypeName = typedExpr nivaType name
        // TODO add it to error list
        TO DO: "Type declared for $valName is not equal for it's value type $astTypeName != $realTypeName"
      ]
    ]

    c defineVar: name withType: typedExpr nivaType

    TypedExpr 
      nivaType: typedExpr nivaType 
      exprAst: this 
      isMutable: typedExpr isMutable
  ]
  | Assign => TO DO
  | DestructingAssign => TO DO
  | ReturnStatement => TO DO: "ReturnStatement to TypedExpr"

  | CodeBlock => TO DO: "CodeBlock to TypedExpr"
  | Match     => TO DO: "Match to TypedExpr"
  | TypedExpr => TO DO: "Compiler bug: Recursive check, $this already type checked"


  // result = TypedExpr nivaType: TO DO isMutable: TO DO
  // ^ result
]


type Tuple x: T y: G 

KeywordMsg getNameFromArgs -> String = [
  ^ args joinWith: ":" transform: [
    it name name
  ], + ":"
]
KeywordMsg resolveKeywordFromDb: db::TyperDB withContext: c::Context = [
  receiverTypedExpr = receiver toTypedExprFromDb: db withContext: c

  typedArgs = args map: [ kwArg -> 
    {name expr} = kwArg
    typedExpr = expr toTypedExprFromDb: db withContext: c
    NameAndExpr name: name expr: typedExpr
  ]
  
  // так стоп, а как мы храним кейворды? вмеесте с :, потому что в этой реализации мы не разделяем сообщения по видам в базе
  foundMsg = db 
    findMsgFromReceiver: receiverTypedExpr nivaType 
    byName: .getNameFromArgs
  
  foundMsg debug

  newKeyword = KeywordMsg 
    args: typedArgs 
    receiver: receiverTypedExpr 
    token: token
  // newKeyword debug

  ^TypedExpr 
    exprAst: newKeyword
    nivaType: (TO DO: "return")
    isMutable: false 
    token: token
] 


/// since every unary contain its own return type
/// and identifiers cant contain types
/// we replacing each of its args with typed expr wich same identifiers
UnaryMsg replaceArgsWithTypedfromDb: db::TyperDB withContext: c::Context -> Tuple(UnaryMsg, NivaType) = [
  
  // recreate receiver
  receiverTypedExpr = receiver toTypedExprFromDb: db withContext: c

  typeOfReceiver = receiverTypedExpr nivaType
  // recreate args

  mut lastType::NivaType? = null

  typedArgs = args map: [ unary ->
    dbMsg = db findMsgFromReceiver: typeOfReceiver  byName: unary name name

    dbMsg args isNotEmpty ifTrue: [TO DO: "Compiler bug, unary $dbMsg with arguments in db"]

    // create typed expr with return type of dbMsg in db message
    dbMsg returnType
    typed = TypedExpr 
      exprAst: unary name 
      nivaType: dbMsg returnType 
      isMutable: false 
      token: unary name token

    lastType <- dbMsg returnType
    NameAndExpr name: unary name expr: typed
  ]

  newUnary = UnaryMsg args: typedArgs receiver: receiverTypedExpr token: token
  ^ Tuple x: newUnary y: lastType unpackOrPANIC
]