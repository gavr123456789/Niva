
/// every [] have a context
type Context 
  parent: Context?
  vars: mut Map(String, NivaType)
  currentPkg: NivaPkg



constructor Context [
  /// no parents no vars(yet)
  on rootWithPkg: currentPkg::NivaPkg = Context parent: null vars: #{}! :currentPkg
  on fromParent::Context = 
    Context parent: fromParent vars: #{}! currentPkg: fromParent currentPkg
]

extend Context [

  // TODO store token with, no, need to store typed expr since all typeInfo is from there
  // TODO or add new TypeFlags type and store it inside typedExpr, to be more flexible(not always we have typedExpr, for example for kw msg params)


  // TODO need to store 
  on defineVar: name::String withType::NivaType = [
    varType = vars at: name
    | varType
    | null => vars at: name put: withType
    |=> [ TO DO: "variable $name with type $varType was already declared, declare it with mut and use <- instead of = for mutation" ]    
  ]
  
  /// if not found, try to search in the parent
  on lookupForVar: name::String -> NivaType? = [
    result = vars at: name
    localP = parent
   ^| result 
    | null => [
        | localP
        | null => null
        |=> localP lookupForVar: name
    ]
    |=> result
  ]

  on allKnownVars -> String = [
    compute = [c::Context ->
      c vars map: [k, v -> "$k: $v"], joinWith: ", "
    ]

    result::{String}! = {(compute c: this)}!
    
    mut p = parent
    [p != null] whileTrue: [
      nonNullP = p unpackOrPANIC
      newLine = compute c: nonNullP
      result add: newLine
      // result <- newLine + "\n" +levelStr + result
      p <- nonNullP parent
    ]
    mut level = -1
    ^result reversed joinWith: "\n" transform: [      
      level <- level inc
      levelStr = "  " repeat: level
      levelStr + it
    ]
  ]
]