
KeywordMsg resolveKeywordFromDb2: db::TyperDB withContext: c::Context  -> KeywordMsgT = [
  receiverTypedExpr = receiver toTypedExprFromDb2: db withContext: c
  receiverType = receiverTypedExpr typeInfo t
  argTypesAndExprs :: mut List::CheckMethodArg = {}!


  // так стоп, а как мы храним кейворды? вмеесте с :, потому что в этой реализации мы не разделяем сообщения по видам в базе
  mut kwMsgDB = db
    findMsgFromReceiver: receiverTypedExpr
    byName: .getNameFromArgs
    currentPkg: c currentPkg
  // just replace this mutability with flag
  // hasGenerics
  // and at the end if it has then use the new generated kwMsg with instantiated geneircs, if not then use kwMsgDB

  Assert that: kwMsgDB args count equals: args count



  // Всю эту часть потом нужно перенести в checkRealArgs: чтобы оно работало и для байнари

  // GENERICS

  letterToType::mut Map(String, NivaType) = #{}!

  typedArgs = args mapIndexed: [ i, kwArg ->
    {name expr} = kwArg
    typedExpr = expr toTypedExprFromDb2: db withContext: c
    realType = typedExpr typeInfo t
    argTypesAndExprs add: (CheckMethodArg
                            nivaType: typedExpr typeInfo t
                            expr: expr
                            argName: name name)

    argTypeFromDb = kwMsgDB args at: i, typeT
    | argTypeFromDb | UnresolvedGenericT => [
      // Check if we already resolved same letter to different type
      letterToType at: argTypeFromDb letter, unpack: [ alreadyResolvedTo::NivaType ->
        alreadyResolvedTo compareWith: typedExpr typeInfo t, ifFalse: [
          l = argTypeFromDb letter
          to = typedExpr typeInfo t
          TO DO: "Cant resolve $l to $to, it was already resolved to $alreadyResolvedTo"
        ]
      ]

      letterToType
        at: argTypeFromDb letter
        put: realType
    ] |=> [
      // вот, если это не женерик то сравниваем с тем шо в дб
      realType compareWith: argTypeFromDb, ifFalse: [
        db addErrorMessage: (ErrorWrongArgType
                              tok: expr token
                              msg: "Expected " + argTypeFromDb toString + " but got " + realType toString)
      ]
    ]
    // Да тут можно сразу и проверять тип чеуж там

    NameAndExprT name: name expr: typedExpr
  ]

  // щас тут логика ветвится
  // дженерик не дженерик ресивер
  // дженерик не дженерик конструктор
  // дженерик не дженерик обычное сообщение
  //
  // нужно просто по отдельности - полностью обработать ресивер заменив при надобности его на новый замененный
  // потом полностью обработать сообщение

  // К этому моменту мы проверили обычные типы, и получили таблицу женериков
  // теперь можно сгенерировать Msg с замененными женериками из оригинального, или получить если он уже был сгенерен
  // у инстанциированных типов, должны быть инстанциированные сообщения
  // мы будем затем находит интанциированные типы по id, и затем их сообщения

  // также нужно убрать отдельную таблицу конструкторов, наверное, потому что само сообщение и так содержит kind
  // нет, тогда мы не сможем хранить сообщение и конструктор с одинаковыми названиями

  // try to find by id
  letterToType isNotEmpty ifTrue: [
    // 1) create new type with generic replaced based on receiverType, if it contains generics and this is a constructor
    // 1.1) if type does not contains generics but message contains, it seams okay, we can infer them from args
    // 1.2) if type does contains generics but message dont, then its a problem.
    // 2) create a new message, if it contains any generics, current letter to type not empty means it does

    // Instantiate method and its type if needed
    // replaceGenericsFromTable also instantiates receiver type and registers it in DB
    dontMangle = | receiverType
    | TypeT => (receiverType collectGenerics map: [t::NivaType -> t name]) toSet
    |=> #(String)!

    newMethod = kwMsgDB replaceGenericsFromTable: letterToType dontMangle: dontMangle mangle: true db: db

    // Check if we already have this method instantiation
    // We look in the instantiated cache of the receiver type (which was just updated/created in replaceGenericsFromTable)
    // Or if receiver is not generic but method is, we still need to register it somewhere?
    // Actually replaceGenericsFromTable handles registration of the type.

    // We need to register the method in the receiver type's method table
    // The receiver type of newMethod IS the instantiated type (or original if no change)

    instReceiverType = newMethod receiverType

    // Add method to cache if not present
    // But wait, where is the cache for instantiated methods?
    // It's in db instantiatedCache for instantiated types.
    // For regular types (if method generic), we should probably put it in typeToMethodNameToMethod?
    // Or just in generatedMessageDecls is enough for code gen, but for type checking recursion we need it in DB.

    // We can use addMethod:toProtocol:forType: which handles adding to typeToMethodNameToMethod.
    // But check if it exists first.

    methodAlreadyExists = db findMethodInAllProtocols: newMethod name forType: instReceiverType receiver: receiverTypedExpr currentPkg: c currentPkg dtc: db dtc

    | methodAlreadyExists
    | null => [
       // Method not found, register it

       // 1. Add to DB method cache
       db addNewMethod: newMethod forType: instReceiverType inProtocol: "generated"

       // 2. Generate MessageDecl for backend
       originalDecl = kwMsgDB decl

       | originalDecl
       | null => [] // nothing to generate (e.g. intrinsic or getter without decl)
       |=> [
          // Create new MessageDecl

          // create new body with same expressions but empty typed body
          newBody = Body unTypedBody: (originalDecl body unTypedBody toMutableList) typedBody2: {}!

          // create args
          // args is List<NameAndAstType>
          // we need to update types to mangled names of resolved types
          newArgs = originalDecl args mapIndexed: [ i, arg ->
             // get resolved type from newMethod args
             resolvedArgType = newMethod args at: i, typeT

             NameAndAstType name: arg name astType: (AstType name: resolvedArgType toMangledName tok: (Token fake))
          ]
          newDecl = MessageDecl
            receiver: (AstType name: instReceiverType toMangledName tok: (Token fake))
            name: newMethod name // mangled name if method was generic
            args: newArgs
            returnType: (AstType name: newMethod returnType toMangledName tok: (Token fake))
            body: newBody
            isSingleExpr: originalDecl isSingleExpr
            isConstructor: originalDecl isConstructor
            token: originalDecl token
          // Resolve body of the new declaration to ensure types are correct inside
          newDecl resolveBodyWithDb: db pkg: c currentPkg extraTypes: letterToType

          // Add to generated list for backend
          db addGeneratedMessageDecl: newDecl
       ]
    ]
    |=> [
       // already exists, use it
       // ensure we use the cached one just in case
       // newMethod <- methodAlreadyExists
    ]

    kwMsgDB <- newMethod

  ] ifFalse: [
    // 1.2) check here
    | receiverType
    | TypeT => [
      isThereUnresolvedGenerics = receiverType genericArgs find: [
        | it
        | UnresolvedGenericT => [true]
        |=> [false]
      ]

      isThereUnresolvedGenerics unpack: [
        db addFatalErrorFromTok: receiver token
           withMsg: "Receiver has generic param " + it toString + " but I can't infer it via message arguments"
      ]
    ] |=> []

  ]



  // do not check if they are generics
  // no, probably just replace expected args here with real args, if they are generics

  // db checkRealArgs: argTypesAndExprs withExpectedArgs: kwMsgDB args // мы теперь сравниваем выше "realType compareWith: argTypeFromDb"

  newKeyword = KeywordMsgT
    args: typedArgs
    kind: kwMsgDB kind
    receiver: receiverTypedExpr
    token: token
    typeInfo: (TypeInfo
                  t: kwMsgDB returnType
                  isMut: kwMsgDB forMut)
    dbMsg: kwMsgDB

  // receiver stays non instaciated when its constructor, its pretty logical
  // Box t: 42
  // Box(Box t: T) t: 42(Int)

  ^ newKeyword
]
