
KeywordMsg resolveKeywordFromDb2: db::TyperDB withContext: c::Context  -> KeywordMsgT = [
  receiverTypedExpr = receiver toTypedExprFromDb2: db withContext: c
  receiverType = receiverTypedExpr typeInfo t
  argTypesAndExprs :: mut List::CheckMethodArg = {}!


  // так стоп, а как мы храним кейворды? вмеесте с :, потому что в этой реализации мы не разделяем сообщения по видам в базе
  mut kwMsgDB = db
    findMsgFromReceiver: receiverTypedExpr
    byName: .getNameFromArgs
    currentPkg: c currentPkg

  Assert that: kwMsgDB args count equals: args count

  
  
  // Всю эту часть потом нужно перенести в checkRealArgs: чтобы оно работало и для байнари
  
  // GENERICS
  
  letterToType::mut Map(String, NivaType) = #{}!

  typedArgs = args mapIndexed: [ i, kwArg ->
    {name expr} = kwArg
    typedExpr = expr toTypedExprFromDb2: db withContext: c
    realType = typedExpr typeInfo t
    argTypesAndExprs add: (CheckMethodArg
                            nivaType: typedExpr typeInfo t
                            expr: expr
                            argName: name name)

    argTypeFromDb = kwMsgDB args at: i, typeT
    | argTypeFromDb | UnresolvedGenericT => [
      // Check if we already resolved same letter to different type
      letterToType at: argTypeFromDb letter, unpack: [ alreadyResolvedTo::NivaType ->
        alreadyResolvedTo compareWith: typedExpr typeInfo t, ifFalse: [
          l = argTypeFromDb letter
          to = typedExpr typeInfo t
          TO DO: "Cant resolve $l to $to, it was already resolved to $alreadyResolvedTo"
        ]
      ]

      letterToType
        at: argTypeFromDb letter
        put: realType
    ] |=> [
      // вот, если это не женерик то сравниваем с тем шо в дб
      realType compareWith: argTypeFromDb, ifFalse: [
        db addErrorMessage: (ErrorWrongArgType
                              tok: expr token
                              msg: "Expected " + argTypeFromDb toString + " but got " + realType toString)
      ]
    ]
    // Да тут можно сразу и проверять тип чеуж там

    NameAndExprT name: name expr: typedExpr
  ]


  // К этому моменту мы проверили обычные типы, и получили таблицу женериков
  // теперь можно сгенерировать Msg с замененными женериками из оригинального, или получить если он уже был сгенерен
  // у инстанциированных типов, должны быть инстанциированные сообщения
  // мы будем затем находит интанциированные типы по id, и затем их сообщения

  // также нужно убрать отдельную таблицу конструкторов, наверное, потому что само сообщение и так содержит kind
  // нет, тогда мы не сможем хранить сообщение и конструктор с одинаковыми названиями

  // try to find by id
  letterToType isNotEmpty ifTrue: [
    // 1) create new type with generic replaced based on receiverType, if it contains generics and this is a constructor
    // 1.1) if type does not contains generics but message contains, it seams okay, we can infer them from args
    // 1.2) if type does contains generics but message dont, then its a problem.
    // 2) create a new message, if it contains any generics, current letter to type not empty means it does
    receiverTypedExpr isIdentifierConstructor ifTrue: [
      // GENERIC DEFAULT CONSTRUCTOR - register instantiated variant
      | receiverType
      | TypeT => [
          newMethod = kwMsgDB replaceGenericsFromTable: letterToType db: db

          thisIsConstructor = kwMsgDB isConstructorForReceiver: receiverType
          thisIsConstructor ifTrue: [
            newReceiverType = newMethod receiverType
            | newReceiverType
            | TypeT => [
              cachedMethodsFromInstGenerics = db instantiatedCache at: receiverType
          
              | cachedMethodsFromInstGenerics
              | null => TO DO: "oh no the map of instantiated methods is null, it should be filled with emptyMap when type is registered"
              |=> [
                cachedMethodsFromInstGenerics at: newMethod name putIfAbsent: newMethod
                "Methods: Registrated generic instantiation of method: " + newMethod toString, log 
              ]
              recId = newReceiverType generateId                             // 100% not needed
              recFromDb = db typesById get: recId orPut: [ newReceiverType ] // same
              
              Unit
            ]
            |=> [TO DO: "Compiler bug, should be TypeT"]
            // TO DO: "добавить в таблицу хешей получившийся метод, если его там еще нет"            
          ]
          
          kwMsgDB <- newMethod
          //TO DO: "ADD NEW MSG WITH INSTANTIATED PARAMS, we got our new message registered with id, теперь проверь что когда мы вызовем второй раз, замены не произойдет и мы просто достанем его по id" + 
          //" и нужно как то организовать подмену kwMsgDB на новый метод, а то сейчас внизу используется старый"

      ] |=> [ TO DO: "generic constructor for usual non-TypeT receiver"]
    ] ifFalse: [
      TO DO: "GENERIC MESSAGE(not constructor) FOR OBJ"
    ]
  ] ifFalse: [
    // 1.2) check here
    | receiverType
    | TypeT => [
      isThereUnresolvedGenerics = receiverType genericArgs find: [
        | it
        | UnresolvedGenericT => [true]
        |=> [false]
      ]

      isThereUnresolvedGenerics unpack: [
        db addFatalErrorFromTok: receiver token 
           withMsg: "Receiver has generic param " + it toString + " but I can't infer it via message arguments" 
      ]
    ] |=> []

  ]



  // do not check if they are generics
  // no, probably just replace expected args here with real args, if they are generics

  // db checkRealArgs: argTypesAndExprs withExpectedArgs: kwMsgDB args // мы теперь сравниваем выше "realType compareWith: argTypeFromDb"
  
  newKeyword = KeywordMsgT
    args: typedArgs
    kind: kwMsgDB kind
    receiver: receiverTypedExpr
    token: token
    typeInfo: (TypeInfo
                  t: kwMsgDB returnType
                  isMut: kwMsgDB forMut)
    dbMsg: kwMsgDB
    
  // receiver stays non instaciated when its constructor, its pretty logical
  // Box t: 42
  // Box(Box t: T) t: 42(Int) 
    
  ^ newKeyword
]