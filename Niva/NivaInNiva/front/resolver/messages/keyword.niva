
KeywordMsg resolveKeywordFromDb2(db): TyperDB withContext(c): Context  -> KeywordMsgT = [
  ^ .resolveKeywordFromDb2: db withContext: c nameOverride: null
]

KeywordMsg resolveKeywordFromDb2(db): TyperDB withContext(c): Context nameOverride: String?  -> KeywordMsgT = [
  receiverTypedExpr = receiver toTypedExprFromDb2: db withContext: c
  ^ .resolveKeywordFromDb2: db withContext: c receiverTyped: receiverTypedExpr nameOverride: nameOverride
]

KeywordMsg resolveKeywordFromDb2(db): TyperDB withContext(c): Context receiverTyped::TypedExpr2 nameOverride: String?  -> KeywordMsgT = [
  receiverTypedExpr = receiverTyped
  receiverType = receiverTypedExpr typeInfo t
  db addCollectionInstantiationIfAbsent: receiverType
  argTypesAndExprs :: mut List::CheckMethodArg = {}!


  msgName = | nameOverride
  | null => .getNameFromArgs
  |=> nameOverride
  mut kwMsgDB = db
    findMsgFromReceiver: receiverTypedExpr
    byName: msgName
    currentPkg: c currentPkg
  // just replace this mutability with flag
  // hasGenerics
  // and at the end if it has then use the new generated kwMsg with instantiated geneircs, if not then use kwMsgDB

  Assert that: kwMsgDB args count equals: args count



  // Всю эту часть потом нужно перенести в checkRealArgs: чтобы оно работало и для байнари

  // GENERICS

  letterToType::mut Map(String, NivaType) = #{}!

  typedArgs = args mapIndexed: [ i, kwArg ->
    {name expr} = kwArg
    argTypeFromDb = kwMsgDB args at: i, typeT
    typedExpr =
      | expr
      | CodeBlock => [
        | argTypeFromDb
        | FuntionT => expr resolveWithExpectedType: db withContext: c expectedType: argTypeFromDb
        |=> expr toTypedExprFromDb2: db withContext: c
      ]
      |=> expr toTypedExprFromDb2: db withContext: c

    realType = typedExpr typeInfo t
    argTypesAndExprs add: (CheckMethodArg
                            nivaType: typedExpr typeInfo t
                            expr: expr
                            argName: name name)

    // infer generics from nested types (function return types)
    argTypeFromDb collectGenericMappingsFrom: realType into: letterToType

    argTypeFromDb containsUnresolvedGeneric
      ifTrue: [
        expectedResolved = argTypeFromDb replaceGenericsFromTableDeep: letterToType db: db
        expectedResolved containsUnresolvedGeneric ifFalse: [
          realType compareWith: expectedResolved, ifFalse: [
            db addErrorMessage: (ErrorWrongArgType
                                  tok: expr token
                                  msg: "Expected " + expectedResolved toString + " but got " + realType toString)
          ]
        ]
      ]
      ifFalse: [
        // вот, если это не женерик то сравниваем с тем шо в дб
        realType compareWith: argTypeFromDb, ifFalse: [
          kwName = kwArg name
          db addErrorMessage: (ErrorWrongArgType
                                tok: expr token
                                msg: "wrong arg type for $kwName Expected " + argTypeFromDb toString + " but got " + realType toString)
        ]
      ]
    // Да тут можно сразу и проверять тип чеуж там

    NameAndExprT name: name expr: typedExpr
  ]

  // щас тут логика ветвится
  // дженерик не дженерик ресивер
  // дженерик не дженерик конструктор
  // дженерик не дженерик обычное сообщение
  //
  // нужно просто по отдельности - полностью обработать ресивер заменив при надобности его на новый замененный
  // потом полностью обработать сообщение

  // К этому моменту мы проверили обычные типы, и получили таблицу женериков
  // теперь можно сгенерировать Msg с замененными женериками из оригинального, или получить если он уже был сгенерен
  // у инстанциированных типов, должны быть инстанциированные сообщения
  // мы будем затем находит интанциированные типы по id, и затем их сообщения

  // также нужно убрать отдельную таблицу конструкторов, наверное, потому что само сообщение и так содержит kind
  // нет, тогда мы не сможем хранить сообщение и конструктор с одинаковыми названиями

  // try to find by id
  letterToType isNotEmpty ifTrue: [
    // 1) create new type with generic replaced based on receiverType, if it contains generics and this is a constructor
    // 1.1) if type does not contains generics but message contains, it seams okay, we can infer them from args
    // 1.2) if type does contains generics but message dont, then its a problem.
    // 2) create a new message, if it contains any generics, current letter to type not empty means it does

    // instantiate method and its type if needed
    // replaceGenericsFromTable also instantiates receiver type and registers it in DB
    dontMangle = | receiverType
    | TypeT => (receiverType collectGenerics map: [t::NivaType -> t name]) toSet
    |=> #(String)!

    newMethod = kwMsgDB replaceGenericsFromTable: letterToType dontMangle: dontMangle mangle: true db: db

    // check if this method instantiation already exists
    // instantiated receiver type is already registered in replaceGenericsFromTable

    // register the method in the instantiated receiver type's method table
    instReceiverType = newMethod receiverType
    db addCollectionInstantiationIfAbsent: instReceiverType

    // add the method to the cache if missing
    // instantiated methods go to instantiatedCache
    // generic methods on non generic types go to typeToMethodNameToMethod
    // addMethod:toProtocol:forType: handles insertion


    methodAlreadyExists = db findMethodInAllProtocols: newMethod name forType: instReceiverType receiver: receiverTypedExpr currentPkg: c currentPkg dtc: db dtc

    | methodAlreadyExists
    | null => [
       // Method not found, register it

       // 1. Add to DB method cache
       db addNewMethod: newMethod forType: instReceiverType inProtocol: "generated"

       // 2. Generate MessageDecl for backend
       originalDecl = kwMsgDB decl

       | originalDecl
       | null => [] // nothing to generate (e.g. intrinsic or getter without decl)
       |=> [
          // Create new MessageDecl

          // create new body with same expressions but empty typed body
          newBody = Body unTypedBody: (originalDecl body unTypedBody toMutableList) typedBody2: {}!

          // create args
          // args is List<NameAndAstType>
          // we need to update types to mangled names of resolved types
          newArgs = originalDecl args mapIndexed: [ i, arg ->
             // get resolved type from newMethod args
             resolvedArgType = newMethod args at: i, typeT

             NameAndAstType name: arg name astType: (AstType name: resolvedArgType toMangledName tok: (Token fake))
          ]
          newDecl = MessageDecl
            receiver: (AstType name: instReceiverType toMangledName tok: (Token fake))
            name: newMethod name // mangled name if method was generic
            args: newArgs
            returnType: (AstType name: newMethod returnType toMangledName tok: (Token fake))
            body: newBody
            isSingleExpr: originalDecl isSingleExpr
            isConstructor: originalDecl isConstructor
            token: originalDecl token
          // resolve body of the new declaration to ensure types are correct inside
          newDecl resolveBodyWithDb: db pkg: c currentPkg extraTypes: letterToType

          // add to generated list for backend
          db addGeneratedMessageDecl: newDecl
       ]
    ]
    |=> [
       // already exists, use it
       // ensure we use the cached one just in case
       // newMethod <- methodAlreadyExists
    ]

    kwMsgDB <- newMethod

  ] ifFalse: [
    // 1.2) check here
    | receiverType
    | TypeT => [
      isThereUnresolvedGenerics = receiverType genericArgs find: [
        | it
        | UnresolvedGenericT => [true]
        |=> [false]
      ]

      isThereUnresolvedGenerics unpack: [
        db addFatalErrorFromTok: receiver token
           withMsg: "Receiver has generic param " + it toString + " but I can't infer it via message arguments"
      ]
    ] |=> []

  ]



  // do not check if they are generics
  // no, probably just replace expected args here with real args, if they are generics

  // db checkRealArgs: argTypesAndExprs withExpectedArgs: kwMsgDB args // мы теперь сравниваем выше "realType compareWith: argTypeFromDb"

  newKeyword = KeywordMsgT
    args: typedArgs
    kind: kwMsgDB kind
    receiver: receiverTypedExpr
    token: token
    typeInfo: (TypeInfo
                  t: kwMsgDB returnType
                  isMut: kwMsgDB forMut)
    dbMsg: kwMsgDB

  // receiver stays non instaciated when its constructor, its pretty logical
  // Box t: 42
  // Box(Box t: T) t: 42(Int)

  ^ newKeyword
]
