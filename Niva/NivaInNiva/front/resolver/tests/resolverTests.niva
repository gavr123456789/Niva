
// Test recursiveMessageDeclaration = [
  // shoud be error, but there are no way to typeChecks errors for now
// ]


Test collectionsTesting = mapTry = [
  fileMain = """
    {1 2 3}
    #("1" "2" "3")
    #{1 "a" 2 "b"}
  //{"a" 1 "b" 2}
  """
  result = ResolverHelper
    resolve: #{"main" fileMain}
    entryPoint: "main"

  db = result db
  typedAst = result entryPointExpressions

  checkFirstList = [
    t = typedAst at: 0, typeInfo t
    | t
    | ListT => Assert that: t t name equals: "Int"
    |=> [TO DO: "list expected"]
  ] do

  checkSecondSet = [
    t = typedAst at: 1, typeInfo t
    | t
    | SetT => Assert that: t t name equals: "String"
    |=> [TO DO: "set expected"]
  ] do

  checkThirdMap = [
    t = typedAst at: 2, typeInfo t
    | t
    | MapT => [
      keyType = t k
      valueType = t v
      Assert that: keyType name equals: "Int"
      Assert that: valueType name equals: "String"
    ]
    |=> [TO DO: "map expected but got: $t"]
  ] do

]

Test  codeblockReturnType = [
  fileMain = """
    [
      "sas"
      1 inc
    ]
    [a::Int, b::Int ->
      a + b
    ]


  """

  result = ResolverHelper resolve: #{"main" fileMain} entryPoint: "main"


  db = result db
  typedAst = result entryPointExpressions
  checkFirst = [
    codeBlock = typedAst at: 0
    | codeBlock | CodeBlockT => [
      Assert that: codeBlock args count equals: 0
      t = codeBlock typeInfo t
      | t | FuntionT => [
        Assert that: t returnType name equals: "Int"
      ] |=> [TO DO: "function type expected"]

    ] |=> [TO DO: "codeblock expected"]
  ] do


  checkSecond = [
    codeBlock = typedAst at: 1
    | codeBlock | CodeBlockT => [
      Assert that: codeBlock args count equals: 2



      t = codeBlock typeInfo t
      | t | FuntionT => [
        Assert that: t returnType name equals: "Int"
      ] |=> [TO DO: "function type expected"]

    ] |=> [TO DO: "codeblock expected"]
  ] do

]

Test wrongArgTypeError = [
  fileMain = """
    type Person name: String
    p = Person name: 234
    q = Person name: 'c'
    w = Person name: true
  """


  result = ResolverHelper resolve: #{"main" fileMain} entryPoint: "main"
  db = result db
  typedAst = result fileToStatements at: "main", unpackOrPANIC

  Assert that: db listOfErrors count equals: 3
]

Test scopeVariables = [
  fileMain = """
    a = 0
    block = [
      b = 1
      b inc
      block2 = [
        c = 2
        a inc
      ]
    ]
  """


  result = ResolverHelper resolve: #{"main" fileMain} entryPoint: "main"
  db = result db
  typedAst = result fileToStatements at: "main", unpackOrPANIC
]


Test constructorCall = [
  fileMain = """
    type Person age: Int
    Int sas = [
      p = Person age: 27
    ]

  """


  result = ResolverHelper resolve: #{"main" fileMain} entryPoint: "main"
  db = result db
  typedAst = result fileToStatements at: "main", unpackOrPANIC
  msgDecl = typedAst at: 1

  | msgDecl
  | MessageDecl => [
    varDecl = msgDecl body typedBody2 at: 0

    | varDecl
    | VarDeclarationT => [
      kwMsg = varDecl value
      | kwMsg
      | KeywordMsgT => [
        Assert that: kwMsg kind equals: MessageSendKind.DefaultConstructor
      ]
      |=> TO DO
    ]
    |=> []


  ]
  |=> [TO DO]

]

Test getter = [

  fileMain = """
    type Person age: Int

    Person getAge -> Int = [
      this age
    ]

  """


  result = ResolverHelper resolve: #{"main" fileMain} entryPoint: "main"
  db = result db
  typedAst = result fileToStatements at: "main", unpackOrPANIC
  msgDecl = typedAst at: 1
  | msgDecl
  | MessageDecl => [
    getter = msgDecl body typedBody2 at: 0
    ast = getter
    | ast
    | UnaryMsg => [
      Assert that: ast kind equals: MessageSendKind.Getter
    ]
    |=> []
  ]
  |=>[TO DO]
]

Test resolveAFewDeclarations = [

  fileMain = """
    // type Money declared in a different file
    Int make::Wallet sas::Person -> Int = [
      x::Int = 42
      1 inc dec
      2 + 3
    ]

    type Person age: Int
    type Wallet money: Int

  """

  statements  = TestParse withInput: fileMain expectedCount: -1
  listOfFilesContents = #{"main" statements}
  db = TyperDB new

  msgDecls = TypeDeclVisitor db: db,
    visitAllTypesThenTypesAndMethods: listOfFilesContents
    entryPointStatements: statements

  MsgDeclVisitor new processBodyes: msgDecls db: db

  typesWereRegistered = [
    mainPkg = db packages at: "main", unpackOrPANIC
    mainPkg types at: "Person", unpackOrPANIC
    mainPkg types at: "Wallet", unpackOrPANIC
  ] do

  makeSas = msgDecls at: 0, y
  checkExpressionsTypes = [
    Assert
      that: makeSas body typedBody2 count
      equals: 3
      andSay: "wrong number of expressions"

    varDecl = makeSas body typedBody2 at: 0
    unary = makeSas body typedBody2 at: 1
    binary = makeSas body typedBody2 at: 2

    Assert that: varDecl typeInfo t name equals: "Unit"
    Assert that: unary typeInfo t name equals: "Int"
    Assert that: binary typeInfo t name equals: "Int"

  ] do
]
