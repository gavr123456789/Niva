union Statement token: Token =
| ^Expr
| ReturnStatement   value: Expr?
| ^Declaration
| VarDeclaration    name: String value: Expr 
| Assign            name: String value: Expr
| DestructingAssign names: List::String value: Expr // {name} = person

union Declaration token: Token = 
| TypeDecl name: String fields: List::TypeField
| EnumDecl 
| UnionDecl

| MessageDecl 
  receiver: AstType 
  name: String 
  args: List::NameAndType // 0 = unary, 1 = binary, 2+ = keyword
  returnType: AstType?
  body: List::Statement


// | 
// Int inc::Int = 56
// {name: "inc" expr: 1}

// MessageDecl value: 
//   (MessageSend name: "inc")




// Expressions

union Expr token: Token = 
| ^LiteralExpr
| Identifier     name: String
| ExprInBrackets value: Expr
| MessageSend    args: List::NameAndExpr // args count 1 = unary, 2 = binary >2 = kw
| ^CollectionLiteral
| ^MessageSend2

constructor Identifier fromToken::Token = 
  Identifier name: (fromToken lexeme) token: fromToken
  


type NameAndExpr name: Identifier expr: Expr
type NameAndType name: String astType: AstType

// Messages
enum MessageKind = Unary | Binary | Keyword

// 1 inc 
// {name: "inc" expr: 1}
constructor MessageSend unaryName::Identifier receiver::Expr token::Token = [
  result = 
    MessageSend 
      args: {(NameAndExpr name: unaryName expr: receiver)} 
      token: token
  ^ result
]


// receiver is primary with possible unary, all other messages are aditional arguments

// 1 + 2 + 3 inc
// { {expr: 1 name: ""}, {name: "+" expr: 2 }, {name: "+" expr: {expr: 3, name: "inc" }} }
// if there is no name, then its simple receiver
constructor MessageSend binaryName::Identifier receiver::NameAndExpr arg::Expr token::Token = [
  result = 
    MessageSend 
      args: {receiver, (NameAndExpr name: binaryName expr: arg)} 
      token: token
  ^ result
]

// simple keyword
// 1 from: 2 to: 3
// {{name: "" expr: 1}, {name: "from" expr: 2}, {name: "to" expr: 3}}

// simple binary
// 1 + 2
// {{name: "" expr: 1}, {name: "+" expr: 2}}

// simple unary
// 1 inc dec
// {{name: "dec" expr: {name: "inc" expr: 1}}}

union MessageSend2 receiver: Expr token: Token =
| UnaryMsg 
    args: List::Identifier
| BinaryMsg
    args: List::NameAndExpr // expr - Primary or UnaryMsg
| KeywordMsg
    args: List::NameAndExpr // expr - Primary or UnaryMsg or BinaryMsg

// Simple Unary
// 1 inc
// UnaryMsg args: {"inc"} receiver: 1 token: TO DO
// 1 inc dec
// UnaryMsg args: {"inc", "dec"} receiver: 1 token: TO DO

// Simple Binary
// 1 + 2 + 3
// BinaryMsg args: {{"+" 2}, {"+" 3}} receiver: 1 token: TO DO

// 1 inc dec + 2 inc dec
// unary1 = UnaryMsg args: {"inc", "dec"} receiver: 1
// unary2 = UnaryMsg args: {"inc", "dec"} receiver: 2
// BinaryMsg 
//   receiver: unary1 
//   args: {(name: "+" expr: unary2)} 

// Simple Keyword
// 1 from: 2 to: 3
// KeywordMsg args: {{"from" 2}, {"to" 3}} receiver: 1 

// 1 inc from: 2 to: 3
// KeywordMsg args: {{"from" 2}, {"to" 3}} receiver: (UnaryMsg args: {"inc"} receiver: 1)

// 1 inc + 2 dec from: 3 inc + 4 dec
// unary3 = Unary receiver: 3 args: {"inc"}
// unary4 = Unary receiver: 4 args: {"dec"}
// KeywordMsg
//   args: {{"from" unary3}, {"to" unary4}}
//   receiver: BinaryMsg
//     args: {{"+" 2}, {"+" 4}}
//     receiver: UnaryMsg
//       args: {"inc"}



// OLD
// 1 inc + 2 dec
// {{1 inc}, {name: "+" exrp: (MS expr: 2 name: "dec")}}
// MessageSend 
//       args: {(NameAndExpr name: "inc" expr: (1))} 
//       token: TO DO

// 1 inc dec
// chain
// {name: "dec" expr: MC{expr: 1 name: "inc"}}

// 1 from: 2 to: 3
// {name: "" expr: 1, name: "from" expr: 2, name: "to" expr: 3}


// 1 inc from: 2 to: 3
// MessageSend 
//   receiver: (MessagSend r: IntExpr(1) args: {name: "inc" expr: IntExpr(1)})
//   args: {name: "from" value: 2, name: "to" value: 3}

// Piping is just receiver wrap
// 1 from: 2, to: 3
// MessageSend
//    r: (MessageSend arg: {name: "from" value: 2})
//    args: {{to: 3}

// Types
type AstType 
  name: String 
  nullable: Boolean 
  genericParams: List::AstType
  isMut: Boolean 

constructor AstType name::String nullable::Boolean genericParams::List::AstType = AstType 
  name: name 
  nullable: nullable
  genericParams: genericParams
  isMut: false

constructor AstType name::String = AstType 
  name: name 
  nullable: false
  genericParams: {}
  isMut: false

extend mut AstType [
  on setMutable::Boolean = isMut <- setMutable
]

// Map(Int, String)
// name: Map
// genericParams: {
//   (name: Int ...),
//   (name: String, ...)
//}

// List::Set::Int
// name: List
// genericParams: {
//    (name: Set, 
//     genericParams: {
//       name: Int, ...
//     }
//    )
//}

union Type = 
| UserType name: String fields: Map(String, Type)
| ^InternalType

union InternalType = 
| StringAstType
| IntAstType
| BooleanAstType
| FloatAstType
| DoubleAstType

union CollectionLiteral token: Token elements: List::Expr = 
| ListLiteral 
| SetLiteral
| MapLiteral

union LiteralExpr token: Token = 
| CharExpr
| IntExpr num: Int
| FloatExpr
| DoubleExpr
| StringExpr
| BooleanExpr
| NullExpr
| FloatExpr
| DoubleExpr

