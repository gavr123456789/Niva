type LexTest 
constructor LexTest input::String -> List::Token = [
  l = Lexer input: input
  tokens = l lex orPANIC dropLast: 1  // drop EOF
  ^ tokens
]

constructor LexTest checkThat: input::String equals: list::List::TokenType -> List::Token! = [
  y = LexTest input: input
  x = y map: [it kind]

  Assert 
    that: x count 
    equals: list count
       
  list forEachIndexed: [i, it -> 
    Assert 
      that: it 
      equals: (list at: i)
  ]
  ^ y
]

Test integers = [
  tokens = LexTest input: "11 22 33" 

  expectedKinds = {TokenType.Integer TokenType.Integer TokenType.Integer}
  expectedStarts = {1 4 7}
  expectedEnds =   {3 6 9}

  tokens forEachIndexed: [ i, it ->
    Assert that: it kind equals: (expectedKinds at: i)
    Assert that: it start equals: (expectedStarts at: i)
    Assert that: it end equals: (expectedEnds at: i)
  ]
]
// skiping spaces should append `pos` so tokens have correct start
Test parseFromSpace = [
  tokens = LexTest input: "   1  " 

  expectedKinds = {TokenType.Integer}
  expectedStarts = {4}
  expectedEnds =   {5}

  tokens forEachIndexed: [ i, it ->
    Assert that: it kind equals: (expectedKinds at: i)
    Assert that: it start equals: (expectedStarts at: i)
    Assert that: it end equals: (expectedEnds at: i)
  ]
]

Test words = [
  tokens = LexTest input: "niva nim vala" 

  expectedKinds = {TokenType.Identifier TokenType.Identifier TokenType.Identifier}
  expectedStarts = {1 6 10}
  expectedEnds =   {5 9 14}

  tokens forEachIndexed: [ i, it ->
    Assert that: it kind equals: (expectedKinds at: i)
    Assert that: it start equals: (expectedStarts at: i)
    Assert that: it end equals: (expectedEnds at: i)
  ]
]

Test multiLine = [
  tokens = LexTest input: """
    niva nim
    vala
  """ trimIndent

  expectedKinds = {TokenType.Identifier TokenType.Identifier TokenType.Identifier}
  expectedStarts = {1 6 1}
  expectedEnds =   {5 9 5}
  expectedLines =  {1 1 2}

  tokens forEachIndexed: [ i, it ->
    Assert that: it kind  equals: (expectedKinds at: i)
    Assert that: it start equals: (expectedStarts at: i)
    Assert that: it end   equals: (expectedEnds at: i)
    Assert that: it line  equals: (expectedLines at: i)
  ]
]

Test operators = [
  binSym = {TokenType.BinarySymbol}m
  11 repeat: [binSym add: TokenType.BinarySymbol]
  LexTest 
    checkThat: "== != + - * = <= >= < > || &&" 
    equals: binSym toList
]

Test identifierColon = [
  tokens = LexTest input: "sas:"
  expectedKinds = {TokenType.IdentifierColon}

  tokens forEachIndexed: [ i, it ->
    Assert that: it kind  equals: (expectedKinds at: i)
  ]
]

Test strings = [
  LexTest checkThat: """ "" "sas" "sus" """ 
          equals: {TokenType.String TokenType.String TokenType.String}
]

Test keywords = [
  LexTest checkThat: "type union constructor enum builder mut errordomain true false null on"
          equals: {TokenType.Type 
                   TokenType.Union 
                   TokenType.Constructor 
                   TokenType.Enum 
                   TokenType.Builder 
                   TokenType.Mut 
                   TokenType.ErrorDomain 
                   TokenType.True 
                   TokenType.False 
                   TokenType.Null 
                   TokenType.On}
]
Test singleNum = [
  LexTest checkThat: "1"
          equals: {TokenType.Integer}
]



Test comment = [
  LexTest checkThat: "// qwf ars \" qwf"
          equals: {TokenType.Comment}
]


Test controlFlow = [
  LexTest checkThat: "| => |=> ^ -> <- . ," 
          equals: {TokenType.If 
                   TokenType.Then 
                   TokenType.Else 
                   TokenType.Return 
                   TokenType.ReturnArrow 
                   TokenType.AssignArrow 
                   TokenType.Dot
                   TokenType.Comma
                  }
]