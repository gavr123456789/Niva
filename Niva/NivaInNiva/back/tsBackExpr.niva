type TypeScript


constructor TypeScript  [

    on fullFromResolver: rh::ResolverHelper -> Map(String, String) = [
        db = rh db
        packages = db packages
        "\n" + db structureInfo, debug

        generateImports = [pkg::NivaPkg sb::StringBuilder->
            pkg imports forEach: [
                // import * as core from "./core.js"
                sb append: "import * as "
                sb append: it
                sb append: " from \"./$it.js\"\n"
            ]
            sb appendLine: "\n" // 2
        ]

        outputFileToJS::mut Map(String, String) = #{}!

        rh fileToStatements forEach: [file, statement ->
            // one sb per file
            sb = StringBuilder new

            pkg = packages at: file, unpackOrPANIC

            generateImports pkg: pkg sb: sb

            statement forEach: [
                x = it toTSFromPkg: file
                x != "" ifTrue: [
                    sb appendLine: x
                    sb appendLine: "\n"
                ]
            ]

            outputFileToJS at: file put: sb toString
        ]



        generateMain = [
            x = outputFileToJS at: "entryPoint", unpackOrPANIC
            x + (rh entryPointExpressions joinWith: "\n" transform: [it toTSFromPkg: "entryPoint"])
        ]

        outputFileToJS at: "entryPoint" put: generateMain do
        ^ outputFileToJS
    ]
]


// currentPkg is basically a file name from which this expr is
// this is needed to remove qualifiers from calls from the same file, like
// sas.js contains "function foo(){}" and call it like "sas.foo()", this is wrong
TypedExpr2 toTSFromPkg: currentPkg::String -> String =
| this
| LiteralExprT => .literalToTS
| IdentifierT => .identToTS
| ExprInBracketsT => "(" + (value toTSFromPkg: currentPkg) + ")"
| VarDeclarationT => .varDeclToTSFromPkg: currentPkg
| AssignT => "let " + name + " = " + (value toTSFromPkg: currentPkg)
| DestructingAssignT => TO DO
| CollectionLiteralT => TO DO
| MessageSendT => .msgSendToTSFromPkg: currentPkg
| ReturnStatementT => TO DO
| CodeBlockT => .codeBlockToTSFromPkg: currentPkg
| MatchT => TO DO

CollectionLiteralT toTSFromPkg: currentPkg::String -> String = [
  sb = StringBuilder new
  elementsStr = elements v joinWith: ", " transform: [
    it toTSFromPkg: currentPkg
  ]
  ^ | this
    | ListLiteralT => [
      "[ " + elementsStr + " ]"
    ]
    | SetLiteralT => [
      // new Set([1, 2, 2, 3])
      "new Set([" + elementsStr + "])"
    ]
    | MapLiteralT => [
      //new Map([
      //   ["name", "Ada"],
      //   ["age", 36],
      //   [42, "answer"],
      //   [{ id: 1 }, "object as key"]
      // ]);
      "new Map([" + elementsStr + "])"
    ]

  ^ ""
]

CodeBlockT codeBlockToTSFromPkg: currentPkg::String -> String = [
    argsStr = args joinWith: ", " transform: [
        it name
    ]
    bodyStr = body v joinWith: "\n" transform: [
        it toTSFromPkg: currentPkg
    ]

    ^ "(" + argsStr + ") => {" + bodyStr + "}"
]


VarDeclarationT varDeclToTSFromPkg: currentPkg::String =
    "const " + name  + " = " + (value toTSFromPkg: currentPkg)


IdentifierT identToTS -> String =
    | name
    | "this" => "_this"
    |=> name


LiteralExprT literalToTS -> String =
    token lexeme


MessageSendT msgSendToTSFromPkg: currentPkg::String -> String = [
    rec = receiver
    isDefaultConstructor = dbMsg kind == MessageSendKind.DefaultConstructor

    getReceiverTs = [
        // we dont need to send receiver as first argument when its a constructor(its just a typeName identifier in such cases)
        isDefaultConstructor ifFalse: [
            receiver toTSFromPkg: currentPkg
        ] ifTrue: [
            ""
        ]
    ]


    // we dont need to generate qualifier in the same pkg
    qualifier = currentPkg == dbMsg pkgName ifFalse: [dbMsg pkgName + "."] ifTrue: [""]

    | this
    | UnaryMsgT => [

        | rec
        | CodeBlockT => [
            selector name == "do" ifTrue: [
                ^ "()"
            ]
        ]
        |=> []


        qSelector = isDefaultConstructor ifFalse: [
            // entryPoint.Person2_name_age("sas", 42)
            dbMsg receiverType name + "_" +  selector name
        ] ifTrue: [
            // new Person2("", 23)
            "new " + dbMsg receiverType name
            dbMsg receiverType name + "_" +  selector name
        ]
        newSelector = dbMsg receiverType name + "_" +  selector name
        ^ qualifier + newSelector + "(" + getReceiverTs do + ")"
    ]
    | BinaryMsgT => [
        q = args joinWith: " " transform: [
            it name name + " " + (it expr toTSFromPkg: currentPkg)
        ]
        // if receiver is Supported type for concrete operato like Int\String\Float\Double and '+' then do nothing
        // if not then replace it with function call, like Vector + Vector is Vector_plus(Vector, Vector)
        ^ getReceiverTs do + " " + q
    ]
    | KeywordMsgT => [


    // selector
        newSelector = isDefaultConstructor
            ifFalse: [
                selectorFromArgs = args joinWith: "_" transform: [
                    it name name
                ]
                dbMsg receiverType name + "_" + selectorFromArgs
            ] ifTrue: [
                "new " + dbMsg receiverType name
            ]

        receiverStr = getReceiverTs do
        receiverWithComma = receiverStr == "" ifTrue: [""] ifFalse: [receiverStr + ", "]

    // args
        argsExprStr = args map: [
            it expr toTSFromPkg: currentPkg
        ]
        args = receiverWithComma + (argsExprStr joinWith: ", ")

        ^ qualifier + newSelector + "(" + args + ")"
    ]


    ^ getReceiverTs do
]
