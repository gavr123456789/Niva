type TypeScript


constructor TypeScript  [

    on fullFromResolver(rh): ResolverHelper -> Map(String, String) = [
        db = rh db
        packages = db packages
        //"\n" + db structureInfo, debug

        generateImports = [pkg::NivaPkg sb::StringBuilder ->
            pkg imports forEach: [
                // import * as core from "./core.js"
                sb append: "import * as "
                sb append: it
                sb append: " from \"./$it.js\"\n"
            ]
            sb appendLine: "\n" // 2
        ]

        outputFileToJS::mut Map(String, String) = #{}!

        rh fileToStatements forEach: [file, statement ->
            // one sb per file
            sb = StringBuilder new

            pkg = packages at: file, unpackOrPANIC

            generateImports :pkg :sb

            statement forEach: [
                x = it toTSFromPkg: file db: db
                x != "" ifTrue: [
                    sb appendLine: x
                    sb appendLine: "\n"
                ]
            ]

            outputFileToJS at: file put: sb toString
        ]



        entryPointName = rh entryPointName
        generateMain = [
            x = outputFileToJS at: entryPointName, unpackOrPANIC
            x + (rh entryPointExpressions joinWith: "\n" transform: [it toTSFromPkg: entryPointName])
        ]

        outputFileToJS at: entryPointName put: generateMain do
        ^ outputFileToJS
    ]
]


// currentPkg is basically a file name from which this expr is
// this is needed to remove pkg_qualifiers from calls from the same file, like
// sas.js contains "function foo(){}" and call it like "sas.foo()", this is wrong
TypedExpr2 toTSFromPkg(currentPkg): String -> String =
| this
| LiteralExprT       => .literalToTS
| IdentifierT        => .identToTS
| ExprInBracketsT    => "(" + (value toTSFromPkg: currentPkg) + ")"
| VarDeclarationT    => .varDeclToTSFromPkg: currentPkg
| AssignT            => .generateTSAssignFromPkg: currentPkg
| DestructingAssignT => TO DO
| CollectionLiteralT => .collectionToTSFromPkg: currentPkg
| MessageSendT       => .msgSendToTSFromPkg: currentPkg
| ReturnStatementT   => .returnToTSFromPkg: currentPkg
| CodeBlockT         => .codeBlockToTSFromPkg: currentPkg
| MatchT             => TO DO

/// checks if it a field of receiver than generates _this.field = ...
AssignT generateTSAssignFromPkg(currentPkg): String -> String = [
  need_this = | kind
              | AssignKind.TO_LOCAL_MUT  => ""
              | AssignKind.TO_THIS_FIELD => "_this."
  ^ need_this + name + " = " + (value toTSFromPkg: currentPkg)
]

CollectionLiteralT collectionToTSFromPkg(currentPkg): String -> String = [
  sb = StringBuilder new
  elementsStr = elements v joinWith: ", " transform: [
    it toTSFromPkg: currentPkg
  ]
  ^ | this
    | ListLiteralT => [
      "[ " + elementsStr + " ]"
    ]
    | SetLiteralT => [
      // new Set([1, 2, 2, 3])
      "new Set([" + elementsStr + "])"
    ]
    | MapLiteralT => [
      //new Map([
      //   ["name", "Ada"],
      //   ["age", 36],
      //   [42, "answer"],
      //   [{ id: 1 }, "object as key"]
      // ]);
      "new Map([" + elementsStr + "])"
    ]


]

ReturnStatementT returnToTSFromPkg(currentPkg): String -> String = [
  exprStr = value unpack: [it toTSFromPkg: currentPkg] or: ""
  ^ exprStr == "" ifTrue: ["return"] ifFalse: ["return " + exprStr]
]

CodeBlockT codeBlockToTSFromPkg(currentPkg): String -> String = [
    argsStr = args isNotEmpty
      ifTrue: [
        args joinWith: ", " transform: [
          it name
        ]
      ] ifFalse: [
        untypedArgs isNotEmpty
          ifTrue: [
            untypedArgs joinWith: ", " transform: [
              it name
            ]
          ] ifFalse: [
              p = typeInfo t
            implicitArg = | p
              | FuntionT => [
                p fields count == 1
                  ifTrue: [
                    fieldName = p fields first name
                    fieldName == "" ifTrue: ["it"] ifFalse: [fieldName]
                  ]
                  ifFalse: [""]
              ]
              |=> ""
            implicitArg
          ]
      ]
    bodyExprs = body v
    bodyStr = bodyExprs isEmpty
      ifTrue: [""]
      ifFalse: [
        lastIndex = bodyExprs count - 1
        bodyExprs mapIndexed: [i, expr ->
          isLast = i == lastIndex
          isLast
            ifTrue: [
              | expr
              | ReturnStatementT =>
                expr toTSFromPkg: currentPkg
              | VarDeclarationT
              | AssignT
              | DestructingAssignT =>
                (expr toTSFromPkg: currentPkg) + "\nreturn"
              |=> [
                "return " + (expr toTSFromPkg: currentPkg)
              ]
            ] ifFalse: [
              expr toTSFromPkg: currentPkg
            ]
        ], joinWith: "\n"
      ]

    ^ "(" + argsStr + ") => {" + bodyStr + "}"
]


VarDeclarationT varDeclToTSFromPkg(currentPkg): String =
    "const " + name  + " = " + (value toTSFromPkg: currentPkg)


IdentifierT identToTS -> String =
    | name
    | "this" => "_this"
    |=> name


LiteralExprT literalToTS -> String =
    token lexeme


MessageSendT msgSendToTSFromPkg(currentPkg): String -> String = [
    rec = receiver
    isDefaultConstructor = dbMsg kind == MessageSendKind.DefaultConstructor

    getReceiverTs = [
        // we dont need to send receiver as first argument when its a constructor(its just a typeName identifier in such cases)
        isDefaultConstructor
            ifFalse: [receiver toTSFromPkg: currentPkg]
            ifTrue:  [""]
    ]


    // we dont need to generate pkg_qualifier in the same pkg
    pkg_qualifier = currentPkg == dbMsg pkgName ifFalse: [dbMsg pkgName + "."] ifTrue: [""]

    | this
    | UnaryMsgT => [

        dbMsg kind == MessageSendKind.Getter
            ifTrue: [
                ^ (receiver toTSFromPkg: currentPkg) + "." + selector name
            ]

        | rec
        | CodeBlockT => [
            selector name == "do" ifTrue: [
                ^ "()"
            ]
        ]
        |=> []


        qSelector = isDefaultConstructor ifFalse: [
            // entryPoint.Person2_name_age("sas", 42)
            > dbMsg receiverType toMangledName
            dbMsg receiverType name + "__" +  selector name
        ] ifTrue: [
            // new Person2("", 23)
            "new " + dbMsg receiverType name
            //dbMsg receiverType name + "__" +  selector name
        ]

        newSelector = dbMsg receiverType name + "__" +  selector name
        //qSelector debug
        //newSelector debug

        ^ pkg_qualifier + newSelector + "(" + getReceiverTs do + ")"
    ]
    | BinaryMsgT => [
        q = args joinWith: " " transform: [
            it name name + " " + (it expr toTSFromPkg: currentPkg)
        ]
        // if receiver is Supported type for concrete operato like Int\String\Float\Double and '+' then do nothing
        // if not then replace it with function call, like Vector + Vector is Vector_plus(Vector, Vector)
        ^ getReceiverTs do + " " + q
    ]
    | KeywordMsgT => [
        // selector
        newSelector = isDefaultConstructor
            ifFalse: [
                selectorFromArgs = args joinWith: "_" transform: [
                    it name name
                ]
                suffix = dbMsg name substringAfter: "__"
                hasSuffix = suffix != dbMsg name
                suffixStr = hasSuffix ifTrue: ["__" + suffix] ifFalse: [""]

                dbMsg receiverType name + "__" + selectorFromArgs + suffixStr
            ] ifTrue: [
                "new " + dbMsg receiverType name
            ]

        receiverStr = getReceiverTs do
        receiverWithComma = receiverStr == "" ifTrue: [""] ifFalse: [receiverStr + ", "]

    // args
        argsExprStr = args map: [
            it expr toTSFromPkg: currentPkg
        ]
        args = receiverWithComma + (argsExprStr joinWith: ", ")

        ^ pkg_qualifier + newSelector + "(" + args + ")"
    ]


    ^ getReceiverTs do
]
