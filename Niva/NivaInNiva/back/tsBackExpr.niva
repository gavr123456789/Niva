type TypeScript

constructor TypeScript  [

    on fullFromResolver: rh::ResolverHelper -> Map(String, String) = [
        db = rh db 
        packages = db packages
        "\n" + db structureInfo, debug

        generateImports = [pkg::NivaPkg sb::StringBuilder-> 
            pkg imports forEach: [
                // import * as core from "./core.js"
                sb append: "import * as "
                sb append: it 
                sb append: " from \"./$it.js\"\n"
            ]
            sb appendLine: "\n" // 2
        ]

        outputFileToJS::mut Map(String, String) = #{}! 

        rh fileToStatements forEach: [file, statement -> 
            // one sb per file
            sb = StringBuilder new

            pkg = packages at: file, unpackOrPANIC

            generateImports pkg: pkg sb: sb
            
            statement forEach: [
                x = it toTS 
                x != "" ifTrue: [
                    sb appendLine: x
                    sb appendLine: "\n"
                ]
            ]

            outputFileToJS at: file put: sb toString
        ]



        generateMain = [
            x = outputFileToJS at: "entryPoint", unpackOrPANIC
            x + (rh entryPointExpressions joinWith: "\n" transform: [it toTS])
        ]

        outputFileToJS at: "entryPoint" put: generateMain do
        ^ outputFileToJS
    ]
] 


TypedExpr2 toTS -> String = 
| this
| LiteralExprT => .literalToTS
| IdentifierT => .identToTS
| ExprInBracketsT => "(" + value toTS + ")"
| VarDeclarationT => .varDeclToTS
| AssignT => "let " + name + " = " + value toTS
| DestructingAssignT => TO DO
| CollectionLiteralT => TO DO
| MessageSendT => .msgSendToTS
| ReturnStatementT => TO DO
| CodeBlockT => .codeBlockToTS
| MatchT => TO DO
   
CodeBlockT codeBlockToTS -> String = [
    argsStr = args joinWith: ", " transform: [
        it name
    ]
    bodyStr = body v joinWith: "\n" transform: [
        it toTS
    ]

    ^ "(" + argsStr + ") => {" + bodyStr + "}" 
]


VarDeclarationT varDeclToTS = 
    "const " + name  + " = " + value toTS


IdentifierT identToTS -> String = 
    | name
    | "this" => "_this"
    |=> name 


LiteralExprT literalToTS -> String = 
    token lexeme 


MessageSendT msgSendToTS -> String = [
    r = receiver toTS

    qualifier = pkgName + "."

    | this
    | UnaryMsgT => [
        newSelector =  selector name + "_" + receiver typeInfo t name 
        ^ qualifier + newSelector + "(" + r + ")"
    ]
    | BinaryMsgT => [
        q = args joinWith: " " transform: [
            it name name + " " + it expr toTS
        ]
        ^ r + " " + q
    ]
    | KeywordMsgT => [

        argsStr = args map: [
            it expr toTS
        ]

        selectorFromArgs = args joinWith: "_" transform: [
            it name name
        ]

        newSelector = selectorFromArgs + "_" + receiver typeInfo t name 


        args = r + ", " + (argsStr joinWith: ", ")

        ^ qualifier + newSelector + "(" + args + ")"
    ]
    ^ r
]

